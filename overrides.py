import gradio as gr
import sqlite3
import pandas as pd
import os
import datetime
import socket
import io
from pathlib import Path
import base64  # ADD THIS WITH OTHER IMPORTS
import tempfile  # ADD THIS WITH OTHER IMPORTS
import json
# ======================
# EMAIL CONFIGURATION & HELPERS
# ======================
import os
import re
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import mimetypes


# GET IP ADDRESS TO DISPLAY IN EMAILS
def get_IP():
    # Auto-detect LAN IP address
    local_ip = "127.0.0.1"
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(0.1)
        s.connect(("10.255.255.255", 1))
        local_ip = s.getsockname()[0]
        s.close()
        return local_ip
    except Exception:
        try:
            local_ip = socket.gethostbyname(socket.gethostname())
            if local_ip.startswith("127.") or ":" in local_ip:
                local_ip = "YOUR_LOCAL_IP"
                return local_ip
        except:
            local_ip = "YOUR_LOCAL_IP"    
            return local_ip

MYLOCALIP = get_IP()
GMAIL_APP_PASSWORD = None
# SECURITY: Load credentials from environment variables ONLY (NEVER hardcode)
SENDER_EMAIL = "fabio.matricardi@gmail.com"
SECRETFILE = "secret.json"

try:
    with open(SECRETFILE) as f:
        GMAIL_APP_PASSWORD = json.load(f)['secret_code']
        #print(secret_code)
except FileNotFoundError:
    print("Error: JSON file not found")
except (json.JSONDecodeError, KeyError) as e:
    print(f"Error reading secret_code: {e}")
MANAGER_EMAILS_FILE = "emails.txt"  # File with manager emails (one per line)

def read_manager_emails():
    """Read validated manager emails from file with error handling"""
    email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
    emails = []
    
    if not os.path.exists(MANAGER_EMAILS_FILE):
        return [], f"‚ùå Email file '{MANAGER_EMAILS_FILE}' not found. Create file with manager emails."
    
    try:
        with open(MANAGER_EMAILS_FILE, 'r', encoding='utf-8') as f:
            for line in f:
                email = line.strip()
                if email and not email.startswith('#') and email_pattern.match(email):
                    emails.append(email)
        
        if not emails:
            return [], f"‚ùå No valid emails found in '{MANAGER_EMAILS_FILE}'. Format: one email per line."
        return emails, None
    except Exception as e:
        return [], f"‚ùå Error reading email file: {str(e)}"

def send_email_with_exports(recipients, role, excel_path, pdf_path, custom_note=""):
    """Send email with export attachments - returns status message"""
    if not GMAIL_APP_PASSWORD:
        return "‚ùå EMAIL NOT CONFIGURED: Set FGS_GMAIL_APP_PASSWORD environment variable"
    
    if not recipients:
        return "‚ùå No valid recipients provided"
    
    # Generate timestamp for subject/body
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Build email content
    subject = f"FGS Override Register Export - {timestamp}"
    body = f"""FGS Override Register Export
Generated by: {role}
Timestamp: {timestamp}
{('Note: ' + custom_note) if custom_note else ''}

Attachments:
1. FULL_DATABASE_EXPORT.xlsx - Complete override register
2. CURRENT_VIEW_PRINTOUT.pdf - Filtered table as displayed

‚ö†Ô∏è CONFIDENTIAL: This document contains operational safety data.
Do not forward outside Congo FLNG personnel.

---
Automated message from CCR Master Override Register System
IP ADDRESS: {MYLOCALIP}
"""
    
    # Create message
    message = MIMEMultipart()
    message['Subject'] = subject
    message['From'] = SENDER_EMAIL
    message['To'] = ', '.join(recipients[:3]) + (f" + {len(recipients)-3} more" if len(recipients) > 3 else "")
    
    message.attach(MIMEText(body, 'plain'))
    
    # Attach files
    attachments = []
    for filepath, name in [(excel_path, "FULL_DATABASE_EXPORT.xlsx"), (pdf_path, "CURRENT_VIEW_PRINTOUT.pdf")]:
        if os.path.exists(filepath):
            try:
                ctype, _ = mimetypes.guess_type(filepath)
                maintype, subtype = (ctype or 'application/octet-stream').split('/', 1)
                
                with open(filepath, 'rb') as fp:
                    part = MIMEBase(maintype, subtype)
                    part.set_payload(fp.read())
                encoders.encode_base64(part)
                part.add_header('Content-Disposition', 'attachment', filename=name)
                message.attach(part)
                attachments.append(name)
            except Exception as e:
                print(f"‚ö†Ô∏è  Attachment error ({name}): {str(e)}")
    
    if len(attachments) < 2:
        return f"‚ùå Failed to attach required files. Attached: {', '.join(attachments)}"
    
    # Send email
    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465, timeout=30) as server:
            server.login(SENDER_EMAIL, GMAIL_APP_PASSWORD)
            server.send_message(message, to_addrs=recipients)
        return f"‚úÖ Email sent to {len(recipients)} recipient(s)! ({', '.join(attachments)})"
    except smtplib.SMTPAuthenticationError:
        return "‚ùå EMAIL AUTH FAILED: Invalid GMAIL_APP_PASSWORD. Contact administrator."
    except Exception as e:
        return f"‚ùå Email failed: {str(e)[:100]}"



# ======================
# DATABASE SETUP
# ======================
DB_PATH = "fgs_overrides.db"
EXCEL_PATH = "20260129_CCR_BPO_register_FGS_consolidated.xlsx"

manual_file = "manual.md"  # ‚úÖ Fixed typo
try:
    with open(manual_file, 'r', encoding='utf-8') as f:
        usermanual = f.read()
except FileNotFoundError:
    # ‚úÖ Fallback content if file missing (prevents startup crash)
    usermanual = """# üìò FGS Master Override Register - User Manual
‚ö†Ô∏è **manual.md not found**  
Place your user manual in Markdown format at `manual.md` in the application directory.
"""

def init_database():
    """Initialize SQLite database from Excel file if not exists"""
    if os.path.exists(DB_PATH):
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='overrides'")
        if cursor.fetchone():
            conn.close()
            return
        conn.close()
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS overrides (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            entry_no INTEGER UNIQUE NOT NULL,
            approved TEXT DEFAULT 'NO',
            closed TEXT DEFAULT 'NO',
            time_in TEXT,
            module_parameter TEXT,
            description TEXT,
            alarm TEXT,
            message TEXT,
            priority TEXT,
            status TEXT,
            date_on TEXT,
            requested_by TEXT,
            date_off TEXT,
            removal_requested_by TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')

    # ADD COLUMN MIGRATION AFTER TABLE CREATION (after line 60):
    # Check and add new columns if missing (for existing databases)
    cursor.execute("PRAGMA table_info(overrides)")
    existing_cols = [row[1] for row in cursor.fetchall()]
    if 'approved' not in existing_cols:
        cursor.execute("ALTER TABLE overrides ADD COLUMN approved TEXT DEFAULT 'NO'")
        cursor.execute("UPDATE overrides SET approved = 'NO' WHERE approved IS NULL")
    if 'closed' not in existing_cols:
        cursor.execute("ALTER TABLE overrides ADD COLUMN closed TEXT DEFAULT 'NO'")
        cursor.execute("UPDATE overrides SET closed = 'NO' WHERE closed IS NULL")

    
    try:
        if os.path.exists(EXCEL_PATH):
            df = pd.read_excel(EXCEL_PATH, skiprows=13, header=0)
            df.columns = df.columns.str.strip().str.replace(r'\s+', ' ', regex=True)
            
            column_mapping = {
                'no': 'entry_no', 'No': 'entry_no',
                'Time in': 'time_in', 'Time In': 'time_in',
                'Module Parameter': 'module_parameter',
                'Description': 'description',
                'Alarm': 'alarm',
                'Message': 'message',
                'Priority': 'priority',
                'Status': 'status',
                'Date on': 'date_on', 'Date On': 'date_on',
                'Requested by': 'requested_by', 'Requested By': 'requested_by',
                'Date off': 'date_off', 'Date Off': 'date_off',
                'Removal Requested by': 'removal_requested_by', 'Removal Requested By': 'removal_requested_by'
            }
            
            df = df.rename(columns=column_mapping)
            required_cols = ['entry_no', 'time_in', 'module_parameter', 'description', 
                           'alarm', 'message', 'priority', 'status', 'date_on', 
                           'requested_by', 'date_off', 'removal_requested_by']
            
            for col in required_cols:
                if col not in df.columns:
                    df[col] = ""
            
            df = df[required_cols].copy()
            df['entry_no'] = pd.to_numeric(df['entry_no'], errors='coerce').fillna(0).astype(int)
            df = df[df['entry_no'] > 0]
            
            if not df.empty:
                df.to_sql('overrides', conn, if_exists='append', index=False)
                print(f"Loaded {len(df)} entries from Excel")
            else:
                print("Excel file had no valid entries, using fallback data")
        else:
            print(f"Excel file not found at {EXCEL_PATH}, using fallback data")
    except Exception as e:
        print(f"Excel import failed ({e}), using fallback data")
    
    cursor.execute("SELECT COUNT(*) FROM overrides")
    if cursor.fetchone()[0] == 0:
        # UPDATE FALLBACK DATA (replace lines 108-115):
        fallback_data = [
            (1, "NO", "NO", "1/29/26 9:12", "77ATFZP01-301", "P01 flare vent header GAS detector bypass (forced in logic)", 
             "FGS bypass", "", "critical", "second event - risk assessment ongoing", "1/29/26", "OIM", "", ""),
            (2, "NO", "NO", "1/29/26 9:12", "77ATFZP01-302", "P01 flare vent header GAS detector bypass (forced in logic)", 
             "FGS bypass", "", "critical", "second event - risk assessment ongoing", "1/29/26", "OIM", "", "")
        ]
        # UPDATE INSERT STATEMENT (replace lines 117-122):
        cursor.executemany('''
            INSERT INTO overrides (
                entry_no, approved, closed, time_in, module_parameter, description, alarm, message, 
                priority, status, date_on, requested_by, date_off, removal_requested_by
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', fallback_data)
        print("Inserted fallback data")
    
    conn.commit()
    conn.close()
    print("Database initialized successfully")

# ======================
# AUTHENTICATION & POLICIES
# ======================
USERS = {
    "user": {"password": "user", "role": "viewer"},
    "manager": {"password": "manager", "role": "editor"},
    "admin": {"password": "admin", "role": "admin"}
}

def authenticate(username, password):
    """Validate credentials and return role"""
    user = USERS.get(username)
    if user and user["password"] == password:
        return True, user["role"], f"Welcome {username} ({user['role'].title()})!"
    return False, None, "Invalid credentials. Try: user/user, manager/manager, admin/admin"

def can_create(role): return role in ["viewer", "editor", "admin"]
def can_edit(role): return role in ["editor", "admin"]
def can_delete(role): return role in ["editor", "admin"]

# ======================
# DATABASE OPERATIONS
# ======================
# UPDATE COLUMN DEFINITIONS (REPLACE EXISTING DISPLAY_COLUMNS AND DB_COLUMN_MAPPING)
DISPLAY_COLUMNS = [
    'No', 'Approved', 'Closed', 'Time In', 'Module Parameter', 'Description', 
    'Alarm', 'Message', 'Priority', 'Status', 'Date On', 'Requested By', 
    'Date Off', 'Removal Requested By'
]

DB_COLUMN_MAPPING = {
    'No': 'entry_no',
    'Approved': 'approved',
    'Closed': 'closed',
    'Time In': 'time_in',
    'Module Parameter': 'module_parameter',
    'Description': 'description',
    'Alarm': 'alarm',
    'Message': 'message',
    'Priority': 'priority',
    'Status': 'status',
    'Date On': 'date_on',
    'Requested By': 'requested_by',
    'Date Off': 'date_off',
    'Removal Requested By': 'removal_requested_by'
}
reverse_mapping = {v: k for k, v in DB_COLUMN_MAPPING.items()}

def get_filtered_data(filters, sort_col="entry_no", sort_asc=True):
    """Fetch filtered data with SQL injection protection"""
    conn = sqlite3.connect(DB_PATH)
    
    where_clauses = []
    params = []
    for col, val in filters.items():
        if val and val.strip():
            db_col = DB_COLUMN_MAPPING.get(col, col.replace(" ", "_").lower())
            where_clauses.append(f"{db_col} LIKE ?")
            params.append(f"%{val}%")
    
    where_sql = "WHERE " + " AND ".join(where_clauses) if where_clauses else ""
    order_sql = f"ORDER BY {sort_col} {'ASC' if sort_asc else 'DESC'}"
    
    query = f"SELECT * FROM overrides {where_sql} {order_sql}"
    df = pd.read_sql_query(query, conn, params=params)
    conn.close()
    
    df = df.rename(columns=reverse_mapping)
    
    for col in DISPLAY_COLUMNS:
        if col not in df.columns:
            df[col] = ""
    
    return df[DISPLAY_COLUMNS] if not df.empty else pd.DataFrame(columns=DISPLAY_COLUMNS)

def get_entry_by_no(entry_no):
    """Fetch single entry details"""
    conn = sqlite3.connect(DB_PATH)
    df = pd.read_sql_query("SELECT * FROM overrides WHERE entry_no = ?", conn, params=(entry_no,))
    conn.close()
    if df.empty:
        return None
    
    record = df.iloc[0].to_dict()
    return {reverse_mapping.get(k, k): v for k, v in record.items()}

def save_entry(data, is_new, current_user):
    """Insert or update entry"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    fields = {}
    for ui_col, db_col in DB_COLUMN_MAPPING.items():
        fields[db_col] = data.get(ui_col, "")
    
    if is_new:
        cursor.execute("SELECT MAX(entry_no) FROM overrides")
        max_no = cursor.fetchone()[0] or 0
        entry_no = max_no + 1
        fields['entry_no'] = entry_no
    else:
        entry_no = int(data['No'])
    
    if not fields['requested_by'] and is_new:
        fields['requested_by'] = current_user
    
    if is_new:
        cols = ', '.join(fields.keys())
        placeholders = ', '.join(['?'] * len(fields))
        query = f"INSERT INTO overrides ({cols}) VALUES ({placeholders})"
        cursor.execute(query, list(fields.values()))
    else:
        set_clause = ', '.join([f"{k} = ?" for k in fields.keys() if k != 'entry_no'])
        query = f"UPDATE overrides SET {set_clause} WHERE entry_no = ?"
        cursor.execute(query, [fields[k] for k in fields.keys() if k != 'entry_no'] + [entry_no])
    
    conn.commit()
    conn.close()
    return entry_no

def delete_entry(entry_no):
    """Delete entry by number"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("DELETE FROM overrides WHERE entry_no = ?", (entry_no,))
    conn.commit()
    conn.close()

# ======================
# EXPORT & PRINT FUNCTIONS
# ======================
def export_entire_database(role):
    """Export ENTIRE database to Excel using temporary file (Gradio 4.x compatible)"""
    if not role:
        return None, "‚ùå Not authenticated. Please login first."
    
    try:
        conn = sqlite3.connect(DB_PATH)
        df = pd.read_sql_query("SELECT * FROM overrides", conn)
        conn.close()
        
        df = df.rename(columns=reverse_mapping)
        df = df[[col for col in DISPLAY_COLUMNS if col in df.columns]]
        
        # Create temporary file with proper cleanup
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"FGS_Export_{timestamp}.xlsx"
        temp_dir = tempfile.gettempdir()
        filepath = os.path.join(temp_dir, filename)
        
        # Write Excel file
        with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
            # Title row
            pd.DataFrame([["FGS MASTER OVERRIDE REGISTER - FULL DATABASE EXPORT"]]).to_excel(
                writer, sheet_name='Overrides', index=False, header=False
            )
            # Timestamp row
            pd.DataFrame([[f"Exported on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"]]).to_excel(
                writer, sheet_name='Overrides', startrow=1, index=False, header=False
            )
            # Data rows
            df.to_excel(writer, sheet_name='Overrides', startrow=3, index=False)
        
        return filepath, f"‚úÖ Exported {len(df)} entries to Excel"
    except Exception as e:
        return None, f"‚ùå Export failed: {str(e)}"

def print_current_table_to_pdf(table_df, role):
    """Generate PDF on A3 landscape with optimized layout (no truncation, full readability)"""
    if not role:
        return None, "‚ùå Not authenticated. Please login first."
    
    try:
        from fpdf import FPDF, XPos, YPos
    except ImportError:
        return None, "‚ùå PDF library not installed. Run: pip install fpdf2"
    
    try:
        # Create temp file path (Gradio 4.x compatible)
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        filename = f"FGS_Printout_A3_{timestamp}.pdf"
        temp_dir = tempfile.gettempdir()
        filepath = os.path.join(temp_dir, filename)
        
        # A3 LANDSCAPE: 420mm width √ó 297mm height (vs A4's 297√ó210)
        pdf = FPDF(orientation='L', unit='mm', format='A3')
        pdf.add_page()
        
        # Title section
        pdf.set_font("Helvetica", "B", 16)
        pdf.cell(0, 12, text="CCR MASTER OVERRIDE REGISTER - OFFICIAL PRINTOUT", 
                 new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.set_font("Helvetica", "", 11)
        gen_timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        pdf.cell(0, 9, text=f"Generated on: {gen_timestamp} | User: {role} | Format: A3 Landscape", 
                 new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.ln(8)
        
        # OPTIMIZED COLUMN WIDTHS FOR A3 (Total: 400mm = A3 width - 20mm margins)
        col_widths = [
            8,   # No (increased for better spacing)
            10,   # Approved (NEW)
            10,   # Closed (NEW)            
            28,   # Time In
            30,   # Module Parameter (critical field)
            85,   # Description (MAJOR increase - fits full text)
            22,   # Alarm
            22,   # Message
            17,   # Priority
            60,   # Status (MAJOR increase - fits risk assessments)
            28,   # Date On
            25,   # Requested By
            28,   # Date Off
            25    # Removal Requested By
        ]
        total_width = sum(col_widths)  # 400mm - perfect for A3
        
        # Header row with enhanced styling
        pdf.set_font("Helvetica", "B", 8)
        pdf.set_fill_color(230, 230, 250)  # Light purple header
        headers = DISPLAY_COLUMNS
        
        for i, header in enumerate(headers):
            pdf.cell(col_widths[i], 11, text=str(header), border=1, align='C', fill=True)
        pdf.ln()
        
        # Data rows with dynamic height calculation
        pdf.set_font("Helvetica", "", 7)
        rows = table_df.values.tolist() if not table_df.empty else []
        
        for row in rows:
            # Calculate required row height based on longest text in critical columns
            max_lines = 1
            for i, item in enumerate(row):
                txt = str(item).strip() if pd.notna(item) else ""
                col_width = col_widths[i]
                
                # Critical columns get multi-line support
                if i in [3, 7]:  # Description and Status
                    # Estimate lines needed (8pt font ‚âà 15 chars per 10mm width)
                    chars_per_line = max(1, int(col_width * 1.4))
                    lines = (len(txt) // chars_per_line) + 1
                    max_lines = max(max_lines, lines)
            
            row_height = max(9, max_lines * 4.5)  # Minimum 9mm height
            
            # Draw cells with calculated height
            for i, item in enumerate(row):
                txt = str(item).strip() if pd.notna(item) else ""
                align = 'L'
                
                # Special handling for numeric columns
                if i == 0:  # Entry No
                    align = 'C'
                    if txt.isdigit():
                        txt = str(int(float(txt))) if txt else ""
                
                pdf.cell(col_widths[i], row_height, text=txt, border=1, align=align)
            pdf.ln(row_height)
        
        # Professional footer
        pdf.ln(10)
        pdf.set_font("Helvetica", "I", 10)
        pdf.cell(0, 10, text=f"Document ID: FGS-PRINT-{timestamp.replace('_', '')} | Total Entries: {len(rows)} | CONFIDENTIAL", 
                 new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.set_font("Helvetica", "", 9)
        pdf.cell(0, 8, text="This document is valid only with printed timestamp. Electronic version available in CCR Master Override Register application.", 
                 new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        
        # Save to temp file (Gradio 4.x compatible)
        pdf.output(filepath)
        return filepath, f"‚úÖ A3 PDF generated ({len(rows)} entries) | {gen_timestamp}"
    except Exception as e:
        return None, f"‚ùå PDF generation failed: {str(e)}"


def import_excel_data(file_path, role):
    """Admin-only: Import Excel data appending to database (skip duplicates)"""
    if role != 'admin':
        return "‚ùå Access denied! Admin privileges required for imports."
    if not file_path:
        return "‚ùå No file uploaded. Please select an Excel file."
    
    try:
        if not Path(file_path).suffix.lower() in ['.xlsx', '.xls']:
            return "‚ùå Invalid file type. Please upload .xlsx or .xls files only."
        
        df = pd.read_excel(file_path, skiprows=13, header=0)
        df.columns = df.columns.str.strip().str.replace(r'\s+', ' ', regex=True)
        
        column_mapping = {
            'no': 'entry_no', 'No': 'entry_no',
            'Time in': 'time_in', 'Time In': 'time_in',
            'Module Parameter': 'module_parameter',
            'Description': 'description',
            'Alarm': 'alarm',
            'Message': 'message',
            'Priority': 'priority',
            'Status': 'status',
            'Date on': 'date_on', 'Date On': 'date_on',
            'Requested by': 'requested_by', 'Requested By': 'requested_by',
            'Date off': 'date_off', 'Date Off': 'date_off',
            'Removal Requested by': 'removal_requested_by', 'Removal Requested By': 'removal_requested_by'
        }
        
        # Ensure new columns exist with defaults
        for col in ['approved', 'closed']:
            if col not in df.columns:
                df[col] = "NO"  # Default for missing approval columns
            else:
                # Clean existing values to YES/NO standard
                df[col] = df[col].fillna("NO").apply(
                    lambda x: "YES" if str(x).strip().upper() in ["YES", "Y", "TRUE", "1"] else "NO"
                )        
        df = df.rename(columns=column_mapping)
        required_cols = list(DB_COLUMN_MAPPING.values())
        
        for col in required_cols:
            if col not in df.columns:
                df[col] = ""
        
        df = df[required_cols].copy()
        df['entry_no'] = pd.to_numeric(df['entry_no'], errors='coerce').fillna(0).astype(int)
        df = df[df['entry_no'] > 0].drop_duplicates(subset=['entry_no'])
        
        if df.empty:
            return "‚ùå No valid entries found in file. Check format matches original database."
        
        conn = sqlite3.connect(DB_PATH)
        existing_nos = pd.read_sql_query("SELECT entry_no FROM overrides", conn)['entry_no'].tolist()
        new_entries = df[~df['entry_no'].isin(existing_nos)]
        
        if new_entries.empty:
            conn.close()
            return "‚ÑπÔ∏è All entries already exist in database. No new entries added."
        
        new_entries.to_sql('overrides', conn, if_exists='append', index=False)
        conn.close()
        
        return f"‚úÖ Import successful! Added {len(new_entries)} new entries. ({len(df) - len(new_entries)} duplicates skipped.)"
    except Exception as e:
        return f"‚ùå Import failed: {str(e)}\nEnsure file matches original database format (skip 13 title rows)."

# COLOR STYLING FOR TABLE BASED ON RULES
def style_dataframe_for_display(df):
    """Apply row-wise background coloring based on Approved/Closed status"""
    if df.empty or 'Approved' not in df.columns or 'Closed' not in df.columns:
        return df
    
    def row_styler(row):
        approved = str(row['Approved']).strip().upper()
        closed = str(row['Closed']).strip().upper()
        
        # Apply styling rules
        if approved == 'NO':
            color = 'yellow'  # Pending approval
        elif approved == 'YES' and closed == 'NO':
            color = 'lightgreen'  # Approved but active
        elif approved == 'YES' and closed == 'YES':
            color = 'lightgray'  # Completed/closed
        else:
            return [''] * len(row)
        
        return [f'background-color: {color}; font-weight: bold' if i == 0 else f'background-color: {color}' 
                for i in range(len(row))]
    
    return df.style.apply(row_styler, axis=1)


def generate_email_exports(role, table_df):
    """
    Generate fresh Excel + PDF exports for email (without UI updates)
    Returns: (excel_path, pdf_path, error_message)
    """
    try:
        # Generate Excel export (FULL database)
        excel_path, _ = export_entire_database(role)
        if excel_path is None:
            return None, None, "‚ùå Excel export failed"
        
        # Generate PDF export (CURRENT filtered view)
        pdf_path, _ = print_current_table_to_pdf(table_df, role)
        if pdf_path is None:
            # Cleanup Excel if PDF fails
            try: os.remove(excel_path) 
            except: pass
            return None, None, "‚ùå PDF export failed"
        
        return excel_path, pdf_path, None
    except Exception as e:
        return None, None, f"‚ùå Export generation failed: {str(e)}"


# ======================
# SCHEDULER SECTION
# ======================
import schedule
import threading
import time
import pytz
from datetime import datetime as dt

# CONFIGURE TIMEZONE (CRITICAL FOR CONGO FLNG)
T1 = "08:00"
T2 = "10:00"
T1tracker = f"{T1}"
T2tracker = f"{T2}"
SCHEDULER_TIMEZONE = pytz.timezone('Africa/Brazzaville')  # Congo Republic timezone
LAST_SENT_TRACKER = {T1tracker: None, T2tracker: None}  # Prevent duplicate sends on restart

def send_scheduled_email():
    """Automated daily email to managers with FULL exports (Overrides + Shutdown Logs)"""
    try:
        now = dt.now(SCHEDULER_TIMEZONE)
        timestamp = now.strftime("%Y-%m-%d %H:%M:%S")
        schedule_time = T1 if now.hour < 12 else T2
        
        today = now.date()
        if LAST_SENT_TRACKER[schedule_time] == today:
            print(f"[SCHEDULER] Skipped duplicate send for {schedule_time} on {today}")
            return
        LAST_SENT_TRACKER[schedule_time] = today
        
        print(f"\n{'='*60}")
        print(f"[SCHEDULER] üìß Sending INTEGRATED REPORT at {timestamp} ({schedule_time})")
        print(f"{'='*60}")
        
        managers, error = read_manager_emails()
        if error:
            print(f"[SCHEDULER] ‚ùå Email config error: {error}")
            return
        if not managers:
            print("[SCHEDULER] ‚ùå No valid manager emails found")
            return
        
        # ===== GENERATE OVERRIDE EXPORTS =====
        excel_path, _ = export_entire_database(role="system")
        if not excel_path:
            raise Exception("Override Excel export failed")
        
        full_df = get_filtered_data({})
        pdf_path, _ = print_current_table_to_pdf(full_df, role="system")
        if not pdf_path:
            os.remove(excel_path)
            raise Exception("Override PDF export failed")
        
        
        # ===== BUILD INTEGRATED EMAIL =====
        custom_note = (
            f"AUTOMATED SCHEDULED REPORT\n"
            f"Generated at: {timestamp} (Congo FLNG Time)\n"
            f"Schedule: Daily at {T1} and {T2}\n"
            f"-----------------------------------\n"
            f"IP ADDRESS: {MYLOCALIP}\n"
            f"\nOVERRIDES SUMMARY:\n"
            f"  ‚Ä¢ Total Active: {len(full_df[full_df['Closed'] == 'NO'])}\n"
            f"  ‚Ä¢ Pending Approvals (Yellow): {len(full_df[full_df['Approved'] == 'NO'])}\n"
        )
        
        subject = f"CCR INTEGRATED REPORT - Overrides Log ({timestamp})"
        body = f"""CCR OPERATOR SYSTEM AUTOMATED REPORT
Generated by: System Scheduler
Timestamp: {timestamp} (Congo FLNG Time)
Schedule: Daily at {T1} and {T2} Congo Time

{custom_note}

üìé ATTACHMENTS (2 FILES):
1. OVERRIDES_FULL_DATABASE.xlsx - Complete override register
2. OVERRIDES_CURRENT_VIEW.pdf - Filtered table (A3 Landscape)

‚ö†Ô∏è CONFIDENTIAL: Contains operational safety data. Do not forward outside Congo FLNG personnel.
---
Automated message from CCR Master Override Register System
IP ADDRESS: {MYLOCALIP}
"""
        
        # Create message with all 4 attachments
        message = MIMEMultipart()
        message['Subject'] = subject
        message['From'] = SENDER_EMAIL
        message['To'] = ', '.join(managers[:3]) + (f" + {len(managers)-3} more" if len(managers) > 3 else "")
        message.attach(MIMEText(body, 'plain'))
        
        all_attachments = [
            (excel_path, "OVERRIDES_FULL_DATABASE.xlsx"),
            (pdf_path, "OVERRIDES_CURRENT_VIEW.pdf"),
        ]
        
        attached_names = []
        for filepath, name in all_attachments:
            if os.path.exists(filepath):
                try:
                    ctype, _ = mimetypes.guess_type(filepath)
                    maintype, subtype = (ctype or 'application/octet-stream').split('/', 1)
                    with open(filepath, 'rb') as fp:
                        part = MIMEBase(maintype, subtype)
                        part.set_payload(fp.read())
                    encoders.encode_base64(part)
                    part.add_header('Content-Disposition', 'attachment', filename=name)
                    message.attach(part)
                    attached_names.append(name)
                except Exception as e:
                    print(f"[SCHEDULER] Attachment error ({name}): {str(e)}")
        
        if len(attached_names) < 2:
            for filepath, _ in all_attachments:
                try:
                    if filepath and os.path.exists(filepath):
                        os.remove(filepath)
                except: pass
            raise Exception(f"Failed to attach required files. Attached: {', '.join(attached_names)}")
        
        # Send email
        try:
            with smtplib.SMTP_SSL('smtp.gmail.com', 465, timeout=30) as server:
                server.login(SENDER_EMAIL, GMAIL_APP_PASSWORD)
                server.send_message(message, to_addrs=managers)
        except smtplib.SMTPAuthenticationError:
            for filepath, _ in all_attachments:
                try:
                    if filepath and os.path.exists(filepath):
                        os.remove(filepath)
                except: pass
            raise Exception("EMAIL AUTH FAILED: Invalid GMAIL_APP_PASSWORD")
        
        # Cleanup ALL temp files
        for filepath, _ in all_attachments:
            try:
                if filepath and os.path.exists(filepath):
                    os.remove(filepath)
            except Exception as e:
                print(f"[SCHEDULER] Cleanup warning: {str(e)}")
        
        # Log success
        recipient_count = len(managers)
        print(f"[SCHEDULER] ‚úÖ SUCCESS: Integrated report sent to {recipient_count} manager(s)")
        print(f"              Overrides: OVERRIDES_FULL_DATABASE.xlsx + OVERRIDES_CURRENT_VIEW.pdf")
        print(f"              Next scheduled send: {T2 if schedule_time == T1 else '{T1} (next day)'}")
        print("="*60 + "\n")
        
    except Exception as e:
        print(f"[SCHEDULER] ‚ùå FAILED: {str(e)}")
        import traceback
        traceback.print_exc()

def start_email_scheduler():
    """Initialize background scheduler with Congo timezone awareness"""
    def run_scheduler():
        print("\n" + "="*70)
        print("üìß SCHEDULED EMAIL SYSTEM INITIALIZED")
        print("="*70)
        print(f"üìç Timezone: {SCHEDULER_TIMEZONE}")
        print(f"‚è∞ Schedule: Daily at {T1} and {T2} Congo Time")
        print(f"üì¨ Recipients: Managers from '{MANAGER_EMAILS_FILE}'")
        print(f"üìé Attachments: FULL_DATABASE_EXPORT.xlsx + CURRENT_VIEW_PRINTOUT.pdf")
        print(f"üåê ORIGIN IP ADDRESS:  {MYLOCALIP}")
        print("-"*70)
        
        # Schedule jobs using Congo time
        schedule.every().day.at(T1, SCHEDULER_TIMEZONE).do(send_scheduled_email)
        schedule.every().day.at(T2, SCHEDULER_TIMEZONE).do(send_scheduled_email)
        
        #######################################################
        #######################################################
        # IMMEDIATE TEST ON STARTUP (COMMENT OUT IN PRODUCTION)
        #print("‚ö†Ô∏è  TEST MODE: Sending immediate test email...")
        #send_scheduled_email()
        #######################################################
        
        print("‚úÖ Scheduler active - monitoring for scheduled sends")
        print("="*70 + "\n")
        
        while True:
            schedule.run_pending()
            time.sleep(30)  # Check every 30 seconds
    
    # Start daemon thread (exits when main app exits)
    scheduler_thread = threading.Thread(target=run_scheduler, daemon=True, name="EmailScheduler")
    scheduler_thread.start()
    return scheduler_thread




# ======================
# GRADIO INTERFACE
# ======================
    
with gr.Blocks(title="CCR Override Register") as demo:
    init_database()
    # ======================
    # ACTIVATE EMAIL SCHEDULER (ADD THIS SECTION)
    # ======================
    MYLOCALIP = get_IP()
    local_ip = "127.0.0.1"
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(0.1)
        s.connect(("10.255.255.255", 1))
        local_ip = s.getsockname()[0]
        s.close()
    except Exception:
        try:
            local_ip = socket.gethostbyname(socket.gethostname())
            if local_ip.startswith("127.") or ":" in local_ip:
                local_ip = "YOUR_LOCAL_IP"
        except:
            local_ip = "YOUR_LOCAL_IP"    
    try:
        # Verify email configuration before starting scheduler
        if not GMAIL_APP_PASSWORD:
            print("\n" + "‚ö†Ô∏è  " + "="*68)
            print("‚ö†Ô∏è  EMAIL SCHEDULER DISABLED: Set GMAIL_APP_PASSWORD environment variable")
            print("‚ö†Ô∏è  To enable automated reports:")
            print("‚ö†Ô∏è    GMAIL_APP_PASSWORD='your_16_digit_code'")
            print("‚ö†Ô∏è  " + "="*68 + "\n")
        elif not os.path.exists(MANAGER_EMAILS_FILE):
            print(f"\n‚ö†Ô∏è  EMAIL SCHEDULER DISABLED: Create '{MANAGER_EMAILS_FILE}' with manager emails\n")
        else:
            # START SCHEDULER (runs in background thread)
            scheduler_thread = start_email_scheduler()
            print(f"‚úÖ Email scheduler thread started: {scheduler_thread.name}")
    except Exception as e:
        print(f"\n‚ùå Scheduler initialization failed: {str(e)}\n")

    # PRINT MESSAGES FOR THE SERVER INITIALIZATION    
    border = "=" * 70
    print(f"\n{border}")
    print("üöÄ CCR MASTER OVERRIDE REGISTER - NETWORK ACCESS INFO")
    print(border)
    print(f"üìç LOCAL ACCESS (this machine):  http://127.0.0.1:7860")
    if local_ip != "YOUR_LOCAL_IP":
        print(f"üåê LAN ACCESS (other devices):   http://{local_ip}:7860")
        print(f"üåê LAN ACCESS (other devices):   http://inst.local:7860")
    else:
        print(f"üåê LAN ACCESS: Find your IP address:")
        print(f"   ‚Ä¢ Windows: Open CMD ‚Üí type 'ipconfig' ‚Üí look for 'IPv4 Address'")
        print(f"   ‚Ä¢ Then use: http://<YOUR_IP>:7860 from other devices")
    print("-" * 70)
    print("‚ö†Ô∏è  SECURITY NOTICE")
    print("   ‚Ä¢ Connection uses UNENCRYPTED HTTP - ONLY use on TRUSTED networks")
    print("   ‚Ä¢ Authentication required for all operations")
    print("üîí FIREWALL SETUP (CRITICAL FOR WINDOWS):")
    print("   1. Open 'Windows Security' ‚Üí Firewall & network protection")
    print("   2. Click 'Advanced settings' (left panel)")
    print("   3. Inbound Rules ‚Üí New Rule ‚Üí Port ‚Üí TCP 7860 ‚Üí Allow connection")
    print("   4. Name: 'FGS Override App' ‚Üí Finish")
    print(border + "\n")
    
    # Install PDF dependency if needed (one-time setup)
    try:
        from fpdf import FPDF
        print("‚úÖ PDF generation available (fpdf2 installed)")
    except ImportError:
        print("‚ÑπÔ∏è  PDF generation NOT available. To enable:")
        print("    pip install fpdf2")    
    
    # ======================
    # START USER LOGIN AND MAIN INTERFACE
    # ======================
    role_state = gr.State(None)
    current_entry_state = gr.State(None)
    form_mode_state = gr.State("view")
    
    # LOGIN PAGE
    with gr.Column(visible=True) as login_page:
        with gr.Row():  #equal_height=True
            with gr.Column(scale=1):
                gr.Markdown()
            with gr.Column(scale=1):
                gr.Markdown("# \n# üîí CCR Master Override Register")
                gr.Markdown(f"\n #### Network IP: {MYLOCALIP}")
            with gr.Column(scale=1):
                gr.Markdown()

        gr.Markdown("*(Login with your credentials...)*")
        gr.Markdown("---")
        with gr.Row():
            with gr.Column(scale=1):             
                gr.Image("wisonLOGO.png", width=150, container=False, buttons=[])
                #gr.Image("congoFLNG.png", width=150, container=False, buttons=[])  
            with gr.Column(scale=2):
                username = gr.Textbox(label="Username", placeholder="Enter username")
                password = gr.Textbox(label="Password", type="password", placeholder="Enter password")
                login_btn = gr.Button("Login", variant="primary")
                gr.Markdown("---")
                login_msg = gr.Textbox(label="Status", interactive=False)
            with gr.Column(scale=1):
                gr.Markdown()
                gr.Image("ENIcongo.jpg", width=150, container=False, buttons=[])
                #gr.Image("logo.png", width=150, container=False, buttons=[])
        with gr.Row():
            gr.Markdown("---")
        with gr.Row():    
            with gr.Column(scale=1):
                gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
            with gr.Column(scale=2):
                gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                gr.Markdown(f"#### Network IP: {MYLOCALIP}")

    # MAIN APPLICATION
    with gr.Column(visible=False) as main_app:
        with gr.Row():
            with gr.Column(scale=1, variant='compact'):
                with gr.Row():
                    gr.Image("wisonLOGO.png", height=30, container=False, buttons=[], scale=1)
                    gr.Image("congoFLNG.png", height=30, container=False, buttons=[], scale=1)                       
            with gr.Column(scale=3):
                gr.Markdown()
                gr.Markdown("# üîí CCR Master Override Register")
            with gr.Column(scale=1, variant='compact'):
                gr.Image("ENIcongo.jpg", height=30, container=False, buttons=[], scale=1)
                gr.Image("logo.png", height=30, container=False, buttons=[], scale=1)
        gr.Markdown("---")
        
        with gr.Tabs() as tabs:
            # MAIN REGISTER TAB
            with gr.Tab("üìã Main Register"):
                with gr.Row():
                    user_display = gr.Textbox(label="Logged in as", interactive=False)
                    logout_btn = gr.Button("üö™ Logout", scale=0)
                
                gr.Markdown("## üîç Override Register Entries")
                with gr.Row():
                    # Add this BELOW entry_table in UI definition (around line 340):
                    gr.Markdown("""
                    <div style="display: flex; gap: 20px; margin: 10px 0; padding: 8px; background: #f8f9fa; border-radius: 5px;">
                      <span style="background: yellow; padding: 2px 8px; border-radius: 3px">üü° Pending Approval</span>
                      <span style="background: lightgreen; padding: 2px 8px; border-radius: 3px">üü¢ Active Override</span>
                      <span style="background: lightgray; padding: 2px 8px; border-radius: 3px">‚ö™ Closed</span>
                    </div>
                    """)                    
                filter_inputs = {}
                with gr.Row():
                    for col in DISPLAY_COLUMNS[:4]:
                        filter_inputs[col] = gr.Textbox(label=col, placeholder=f"Filter {col}...", container=False)
                with gr.Row():
                    for col in DISPLAY_COLUMNS[4:8]:
                        filter_inputs[col] = gr.Textbox(label=col, placeholder=f"Filter {col}...", container=False)
                with gr.Row():
                    for col in DISPLAY_COLUMNS[8:]:
                        filter_inputs[col] = gr.Textbox(label=col, placeholder=f"Filter {col}...", container=False)
                
                filter_btn = gr.Button("Apply Filters", variant="secondary")
                

                entry_table = gr.Dataframe(
                    headers=DISPLAY_COLUMNS,
                    datatype=["str"] * len(DISPLAY_COLUMNS),
                    interactive=False,
                    wrap=True,
                    label="Override Entries"
                )
                
                with gr.Row():
                    entry_selector = gr.Dropdown(
                        label="Select Entry No to View/Edit", 
                        choices=[],
                        interactive=True
                    )
                    load_btn = gr.Button("Load Selected Entry", variant="primary")
                    create_btn = gr.Button("‚ûï Create New Entry", variant="secondary")


                
                # Detail form
                gr.Markdown("## üìù Entry Details")
                with gr.Column():
                    form_fields = {}
                    # Row 1: Entry No + New Approval Fields
                    with gr.Row():
                        form_fields['No'] = gr.Number(label="Entry No", interactive=False)
                        form_fields['Approved'] = gr.Dropdown(
                            label="Approved", 
                            choices=["YES", "NO"], 
                            value="NO",
                            interactive=False  # Will be enabled for manager/admin only
                        )
                        form_fields['Closed'] = gr.Dropdown(
                            label="Closed", 
                            choices=["YES", "NO"], 
                            value="NO",
                            interactive=False  # Will be enabled for manager/admin only
                        )
                    
                    # Row 2: Time fields
                    with gr.Row():
                        form_fields['Time In'] = gr.Textbox(label="Time In")
                        form_fields['Date On'] = gr.Textbox(label="Date On")
                        form_fields['Date Off'] = gr.Textbox(label="Date Off")
                    
                    # Row 3: Critical parameters
                    with gr.Row():
                        form_fields['Module Parameter'] = gr.Textbox(label="Module Parameter", scale=2)
                        form_fields['Alarm'] = gr.Textbox(label="Alarm Type")
                        form_fields['Priority'] = gr.Dropdown(
                            label="Priority", 
                            choices=["critical", "high", "medium", "low"],
                            value="critical"
                        )
                    
                    # Remaining fields (unchanged)
                    form_fields['Description'] = gr.Textbox(label="Description", lines=2)
                    form_fields['Message'] = gr.Textbox(label="Message")
                    form_fields['Status'] = gr.Textbox(label="Status", lines=2)
                    form_fields['Requested By'] = gr.Textbox(label="Requested By")
                    form_fields['Removal Requested By'] = gr.Textbox(label="Removal Requested By")
                    
                    # Action buttons (unchanged)
                    with gr.Row():
                        save_btn = gr.Button("üíæ Save Changes", variant="primary", visible=True)
                        delete_btn = gr.Button("üóëÔ∏è Delete Entry", variant="stop", visible=False)
                        cancel_btn = gr.Button("‚Ü∫ Cancel", variant="secondary")
                
                status_msg = gr.Textbox(label="Operation Status", interactive=False)


                # Export/Print Section
                gr.Markdown("## üì§ Export, Print & Email")
                with gr.Row():
                    export_excel_btn = gr.Button("üì§ Export FULL Database to Excel", variant="secondary")
                    print_pdf_btn = gr.Button("üñ®Ô∏è Print CURRENT Table to PDF", variant="secondary")
                    send_email_btn = gr.Button("‚úâÔ∏è Send by Email (Managers)", variant="primary")  # NEW BUTTON
                with gr.Row():
                    export_file = gr.File(label="üì• Download Excel Export", type="filepath", visible=True)
                    print_file = gr.File(label="üñ®Ô∏è Download PDF Printout", type="filepath", visible=True)
                    email_status = gr.Textbox(label="üìß Email Status", interactive=False, visible=True)  # NEW STATUS
                with gr.Row():
                    gr.Markdown("---")
                with gr.Row():    
                    with gr.Column(scale=1):
                        gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
                    with gr.Column(scale=2):
                        gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                        gr.Markdown(f"#### Network IP: {MYLOCALIP}")

            # ADMIN PANEL TAB (only visible to admin)
            with gr.Tab("‚öôÔ∏è Admin Panel", id="admin_tab", visible=False) as admin_tab:
                gr.Markdown("## üîê Admin Operations")
                gr.Markdown("### üì• Import Excel Data")
                gr.Markdown("Upload Excel files matching the original database format. **Existing entries (by Entry No) will be skipped.**")
                with gr.Row():
                    excel_upload = gr.File(
                        label="Upload Excel File (.xlsx/.xls)", 
                        type="filepath", 
                        file_types=[".xlsx", ".xls"]
                    )
                    import_btn = gr.Button("‚úÖ Import Data", variant="primary", size="lg")
                import_status = gr.Textbox(label="Import Status", interactive=False, max_lines=3)
                gr.Markdown("---")
                gr.Markdown("‚ÑπÔ∏è **Import Notes:**\n"
                          "- File must have same structure as original database (skip 13 title rows)\n"
                          "- Only NEW entries (by Entry No) will be added\n"
                          "- Duplicates are automatically skipped\n"
                          "- Admin access required")
                with gr.Row():
                    gr.Markdown("---")
                with gr.Row():    
                    with gr.Column(scale=1):
                        gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
                    with gr.Column(scale=2):
                        gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                        gr.Markdown(f"#### Network IP: {MYLOCALIP}")


            # ===== CUSTOM EMAIL TAB (VISIBLE TO ALL USERS) =====
            with gr.Tab("üìß Custom Email"):
                gr.Markdown("## üìß Send Current Exports to Custom Recipients")
                gr.Markdown("Enter email addresses below (one per line). Attachments will include:")
                gr.Markdown("- **FULL_DATABASE_EXPORT.xlsx**: Complete override register\n- **CURRENT_VIEW_PRINTOUT.pdf**: Filtered table as displayed")
                
                with gr.Row():
                    email_recipients = gr.Textbox(
                        label="Recipient Emails (one per line)",
                        placeholder="manager1@congoflng.com\nsupervisor2@wison.com\nhse@congoflng.com",
                        lines=5,
                        max_lines=20
                    )
                with gr.Row():
                    email_note = gr.Textbox(label="Optional Note (appears in email body)", placeholder="Shift handover report - 06:00")
                    send_custom_btn = gr.Button("üì§ Send Custom Email", variant="primary", size="lg")
                custom_email_status = gr.Textbox(label="Status", interactive=False, max_lines=3)
                
                gr.Markdown("---")
                gr.Markdown("‚ÑπÔ∏è **Security Notes**:\n- Emails sent via secure Gmail API\n- Attachments contain CONFIDENTIAL operational data\n- Only send to authorized Congo FLNG personnel\n- System logs all email requests")
                with gr.Row():
                    gr.Markdown("---")
                with gr.Row():    
                    with gr.Column(scale=1):
                        gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
                    with gr.Column(scale=2):
                        gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                        gr.Markdown(f"#### Network IP: {MYLOCALIP}")


    # ===== EVENT HANDLERS =====
    def login_action(uname, pwd):
        if not uname or not uname.strip():
            return _create_login_response(
                login_msg_text="‚ö†Ô∏è Username cannot be empty",
                keep_username=""
            )
        
        if not pwd or not pwd.strip():
            return _create_login_response(
                login_msg_text="‚ö†Ô∏è Password cannot be empty",
                keep_username=uname.strip()
            )
        
        success, role, auth_msg = authenticate(uname.strip(), pwd.strip())
        if not success:
            return _create_login_response(
                login_msg_text="‚ùå Invalid credentials! Try: user/user, manager/manager, or admin/admin",
                keep_username=uname.strip()
            )
        
        df = get_filtered_data({})
        raw_df = get_filtered_data({})
        styled_df = style_dataframe_for_display(raw_df)
        entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
        form_vals = {k: "" for k in DISPLAY_COLUMNS}
        form_vals['Priority'] = "critical"
        
        outputs = {
            login_page: gr.update(visible=False),
            main_app: gr.update(visible=True),
            login_msg: gr.update(value=""),
            user_display: gr.update(value=f"{uname} ({role.title()})"),
            role_state: role,
            entry_table: styled_df,  # Replace df with styled_df
            entry_selector: gr.update(choices=entry_nums),
            status_msg: auth_msg,
            admin_tab: gr.update(visible=(role == "admin")),
        }
        for col in DISPLAY_COLUMNS:
            if col == 'Priority':
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
            else:
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
        outputs[save_btn] = gr.update(visible=False)
        outputs[delete_btn] = gr.update(visible=False)
        outputs[form_mode_state] = "view"
        outputs[username] = gr.update(value="")
        outputs[password] = gr.update(value="")
        outputs[export_file] = None  # Clears file download link
        outputs[print_file] = None   # Clears file download link
        return outputs

    def _create_login_response(login_msg_text, keep_username):
        form_vals = {k: "" for k in DISPLAY_COLUMNS}
        form_vals['Priority'] = "critical"
        
        outputs = {
            login_page: gr.update(visible=True),
            main_app: gr.update(visible=False),
            login_msg: gr.update(value=login_msg_text),
            user_display: gr.update(value=""),
            role_state: None,
            entry_table: pd.DataFrame(columns=DISPLAY_COLUMNS),
            entry_selector: gr.update(choices=[], value=None),
            status_msg: gr.update(value=""),
            admin_tab: gr.update(visible=False),
        }
        for col in DISPLAY_COLUMNS:
            if col == 'Priority':
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
            else:
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
        outputs[save_btn] = gr.update(visible=False)
        outputs[delete_btn] = gr.update(visible=False)
        outputs[form_mode_state] = "view"
        outputs[username] = gr.update(value=keep_username)
        outputs[password] = gr.update(value="")
        outputs[export_file] = None  # Clears file download link
        outputs[print_file] = None   # Clears file download link
        return outputs
    
    def logout_action():
        form_vals = {k: "" for k in DISPLAY_COLUMNS}
        form_vals['Priority'] = "critical"
        
        outputs = {
            login_page: gr.update(visible=True),
            main_app: gr.update(visible=False),
            username: gr.update(value=""),
            password: gr.update(value=""),
            login_msg: "Logged out successfully",
            role_state: None,
            admin_tab: gr.update(visible=False),
            export_file: gr.update(visible=False),
            print_file: gr.update(visible=False),
        }
        for col in DISPLAY_COLUMNS:
            if col == 'Priority':
                outputs[form_fields[col]] = gr.update(value=form_vals[col])
            else:
                outputs[form_fields[col]] = gr.update(value=form_vals[col])
        return outputs
    
    def apply_filters(*args):
        if len(args) < 15:  # 14 filters + role
            return {status_msg: "Filter error: insufficient inputs"}
        
        filter_vals = args[:14]
        role = args[14]
        
        filters = dict(zip(DISPLAY_COLUMNS, filter_vals))
        raw_df = get_filtered_data(filters)  # Keep raw for selector
        styled_df = style_dataframe_for_display(raw_df)  # Style for display
        
        entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
        
        return {
            entry_table: styled_df,  # CRITICAL: Use styled version
            entry_selector: gr.update(choices=entry_nums),
            status_msg: f"Showing {len(raw_df)} entries"
        }
    
    def load_entry(entry_no_str, role):
        if not entry_no_str or not entry_no_str.strip():
            return {status_msg: "Please select an entry number"}
        
        try:
            entry_no = int(float(entry_no_str))
        except (ValueError, TypeError):
            return {status_msg: "Invalid entry number"}
        
        entry = get_entry_by_no(entry_no)
        if not entry:
            return {status_msg: f"Entry #{entry_no} not found"}
        
        form_vals = {}
        for col in DISPLAY_COLUMNS:
            val = entry.get(col, "")
            if col == 'No':
                try:
                    form_vals[col] = int(float(val)) if val else entry_no
                except:
                    form_vals[col] = entry_no
            else:
                form_vals[col] = str(val) if pd.notna(val) else ""
        
        interactive = can_edit(role)
        
        outputs = {
            current_entry_state: entry_no,
            form_mode_state: "edit",
            status_msg: f"Loaded entry #{entry_no} | Role: {role}",
        }

        # CRITICAL: Set interactivity for new fields
        approved_interactive = can_edit(role)
        closed_interactive = can_edit(role)            
        for col in DISPLAY_COLUMNS:
            if col == 'No':
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
            elif col == 'Approved':
                outputs[form_fields[col]] = gr.update(
                    value=form_vals[col] if form_vals[col] in ["YES", "NO"] else "NO",
                    interactive=approved_interactive
                )
            elif col == 'Closed':
                outputs[form_fields[col]] = gr.update(
                    value=form_vals[col] if form_vals[col] in ["YES", "NO"] else "NO",
                    interactive=closed_interactive
                )
            elif col == 'Priority':
                outputs[form_fields[col]] = gr.update(
                    value=form_vals[col] if form_vals[col] in ["critical", "high", "medium", "low"] else "critical",
                    interactive=can_edit(role)
                )
            else:
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=can_edit(role))
        
        outputs[save_btn] = gr.update(visible=can_edit(role))
        outputs[delete_btn] = gr.update(visible=can_delete(role))
        return outputs
    
    def create_new(role):
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT MAX(entry_no) FROM overrides")
        next_no = (cursor.fetchone()[0] or 0) + 1
        conn.close()
        
        now = datetime.datetime.now().strftime("%m/%d/%y %H:%M")
        today = datetime.datetime.now().strftime("%m/%d/%y")
        
        form_vals = {
            'No': next_no,
            'Approved': 'NO',  # Default values
            'Closed': 'NO',
            'Time In': now,
            'Module Parameter': "",
            'Description': "",
            'Alarm': "FGS bypass",
            'Message': "MOS active",
            'Priority': "critical",
            'Status': "",
            'Date On': today,
            'Requested By': role.capitalize(),
            'Date Off': "",
            'Removal Requested By': ""
        }
        
        outputs = {
            current_entry_state: None,
            form_mode_state: "create",
            status_msg: f"Creating new entry (No. {next_no}) | Role: {role}",
        }
        # CRITICAL: Set interactivity for new fields based on role
        approved_interactive = can_edit(role)  # Only manager/admin
        closed_interactive = can_edit(role)    # Only manager/admin
        
        for col in DISPLAY_COLUMNS:
            if col == 'No':
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
            elif col in ['Approved', 'Closed']:
                outputs[form_fields[col]] = gr.update(
                    value=form_vals[col], 
                    interactive=approved_interactive if col=='Approved' else closed_interactive
                )
            elif col == 'Priority':
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=True)
            else:
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=True)
        
        outputs[save_btn] = gr.update(visible=can_create(role), value="‚úÖ Create New Entry")
        outputs[delete_btn] = gr.update(visible=False)
        return outputs
    
    def save_action(*args):
        if len(args) < 17:  
            return {status_msg: f"Save error: insufficient inputs (expected 17, got {len(args)})"}
        
        # WAS: args[:12] ‚Üí NOW: args[:14] for all form fields
        field_vals = args[:14]  
        role = args[14]      # WAS args[12]
        mode = args[15]      # WAS args[13]
        current_no = args[16]  # WAS args[14]
        
        data = dict(zip(DISPLAY_COLUMNS, field_vals))  # Now includes Approved/Closed
        
        # Validation (unchanged)
        if not data['Module Parameter'].strip():
            return {status_msg: "Error: Module Parameter is required"}
        if not data['Description'].strip():
            return {status_msg: "Error: Description is required"}
        
        try:
            saved_no = save_entry(data, mode == "create", role)
            action = "created" if mode == "create" else "updated"
            
            df = get_filtered_data({})
            raw_df = get_filtered_data({})
            styled_df = style_dataframe_for_display(raw_df)
            entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
            
            outputs = {
                status_msg: f"Entry #{saved_no} successfully {action}!",
                entry_table: styled_df,  # Replace df with styled_df
                entry_selector: gr.update(choices=entry_nums),
                export_file: None,  # Clear previous exports
                print_file: None,   # Clear previous prints
            }
            
            if mode == "create":
                # Reset to NEW blank form (not load saved entry)
                outputs.update(create_new(role))  
            else:
                # Only reload for EDIT mode
                outputs.update(load_entry(str(saved_no), role))  
            
            return outputs
            
        except Exception as e:
            return {status_msg: f"Save failed: {str(e)}"}
    
    def delete_action(entry_no, role):
        if not can_delete(role):
            return {status_msg: "Insufficient permissions to delete entries"}
        if not entry_no:
            return {status_msg: "No entry selected for deletion"}
        
        try:
            delete_entry(entry_no)
            df = get_filtered_data({})
            aw_df = get_filtered_data({})
            styled_df = style_dataframe_for_display(raw_df)
            entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
            
            form_vals = {k: "" for k in DISPLAY_COLUMNS}
            form_vals['Priority'] = "critical"
            
            outputs = {
                status_msg: f"Entry #{entry_no} deleted successfully",
                entry_table: styled_df,  # Replace df with styled_df
                entry_selector: gr.update(choices=entry_nums),
                export_file: gr.update(visible=True),
                print_file: gr.update(visible=True),
            }
            for col in DISPLAY_COLUMNS:
                if col == 'Priority':
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
                else:
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
            
            outputs[save_btn] = gr.update(visible=False)
            outputs[delete_btn] = gr.update(visible=False)
            outputs[form_mode_state] = "view"
            return outputs
            
        except Exception as e:
            return {status_msg: f"Delete failed: {str(e)}"}
    
    def cancel_action(role):
        form_vals = {k: "" for k in DISPLAY_COLUMNS}
        form_vals['Priority'] = "critical"
        
        outputs = {
            status_msg: "Changes cancelled",
            form_mode_state: "view",
            current_entry_state: None,
            export_file: gr.update(visible=True),
            print_file: gr.update(visible=True),
        }
        for col in DISPLAY_COLUMNS:
            if col == 'Priority':
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
            else:
                outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
        
        outputs[save_btn] = gr.update(visible=False)
        outputs[delete_btn] = gr.update(visible=False)
        return outputs
    
    # ===== EVENT BINDINGS =====
    login_btn.click(
        login_action,
        inputs=[username, password],
        outputs=[
            login_page, main_app, login_msg, user_display, role_state, 
            entry_table, entry_selector, status_msg, admin_tab,
            *[form_fields[col] for col in DISPLAY_COLUMNS],
            save_btn, delete_btn, form_mode_state,
            username, password, export_file, print_file
        ]
    )
    
    logout_btn.click(
        logout_action,
        outputs=[
            login_page, main_app, username, password, login_msg, role_state, admin_tab,
            *[form_fields[col] for col in DISPLAY_COLUMNS],
            export_file, print_file
        ]
    )
    
    filter_btn.click(
        apply_filters,
        inputs=[*[filter_inputs[col] for col in DISPLAY_COLUMNS], role_state],
        outputs=[entry_table, entry_selector, status_msg]
    )
    
    load_btn.click(
        load_entry,
        inputs=[entry_selector, role_state],
        outputs=[
            current_entry_state, form_mode_state, status_msg,
            *[form_fields[col] for col in DISPLAY_COLUMNS],
            save_btn, delete_btn
        ]
    )
    
    create_btn.click(
        create_new,
        inputs=[role_state],
        outputs=[
            current_entry_state, form_mode_state, status_msg,
            *[form_fields[col] for col in DISPLAY_COLUMNS],
            save_btn, delete_btn
        ]
    )
    
    save_btn.click(
        save_action,
        inputs=[
            *[form_fields[col] for col in DISPLAY_COLUMNS],
            role_state, form_mode_state, current_entry_state
        ],
        outputs=[
            status_msg, entry_table, entry_selector,
            current_entry_state, form_mode_state,
            *[form_fields[col] for col in DISPLAY_COLUMNS],
            save_btn, delete_btn, export_file, print_file
        ]
    )
    
    delete_btn.click(
        delete_action,
        inputs=[current_entry_state, role_state],
        outputs=[
            status_msg, entry_table, entry_selector,
            *[form_fields[col] for col in DISPLAY_COLUMNS],
            save_btn, delete_btn, form_mode_state, export_file, print_file
        ]
    )
    
    cancel_btn.click(
        cancel_action,
        inputs=[role_state],
        outputs=[
            status_msg, form_mode_state, current_entry_state,
            *[form_fields[col] for col in DISPLAY_COLUMNS],
            save_btn, delete_btn, export_file, print_file
        ]
    )
    
    # Export/Print bindings
    export_excel_btn.click(
        export_entire_database,
        inputs=[role_state],
        outputs=[export_file, status_msg]
    )

    print_pdf_btn.click(
        print_current_table_to_pdf,
        inputs=[entry_table, role_state],
        outputs=[print_file, status_msg]
    )
    # Admin import binding
    # REMOVE existing import_btn.click chain and REPLACE with:
    def refresh_table_after_import(role):
        """Helper: Refresh table with styling + update selector"""
        raw_df = get_filtered_data({})
        styled_df = style_dataframe_for_display(raw_df)
        entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
        return styled_df, gr.update(choices=entry_nums)

    import_btn.click(
        import_excel_data,
        inputs=[excel_upload, role_state],
        outputs=[import_status]
    ).then(
        refresh_table_after_import,
        inputs=[role_state],
        outputs=[entry_table, entry_selector]  # Single call updates both
    )


    # ===== EMAIL FUNCTIONALITY =====
    def send_to_managers(role, table_df):
        """Send exports to managers from emails.txt"""
        if not role:
            return "‚ùå Not authenticated. Please login first."
        
        managers, error = read_manager_emails()
        if error:
            return error
        
        excel_path, pdf_path, gen_error = generate_email_exports(role, table_df)
        if gen_error:
            return gen_error
        
        status = send_email_with_exports(managers, role, excel_path, pdf_path)
        
        # Cleanup temp files
        for path in [excel_path, pdf_path]:
            try: 
                if path and os.path.exists(path): 
                    os.remove(path)
            except: 
                pass
        
        return status

    def send_to_custom(role, table_df, recipients_text, note):
        """Send exports to custom email list"""
        if not role:
            return "‚ùå Not authenticated. Please login first."
        
        # Parse and validate emails
        email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        recipients = []
        invalid = []
        
        for line in recipients_text.strip().split('\n'):
            email = line.strip()
            if email and not email.startswith('#'):
                if email_pattern.match(email):
                    recipients.append(email)
                else:
                    invalid.append(email)
        
        if invalid:
            return f"‚ùå Invalid emails skipped: {', '.join(invalid[:3])}{'...' if len(invalid)>3 else ''}"
        if not recipients:
            return "‚ùå No valid email addresses provided. Enter one per line."
        
        excel_path, pdf_path, gen_error = generate_email_exports(role, table_df)
        if gen_error:
            return gen_error
        
        status = send_email_with_exports(recipients, role, excel_path, pdf_path, note)
        
        # Cleanup
        for path in [excel_path, pdf_path]:
            try: 
                if path and os.path.exists(path): 
                    os.remove(path)
            except: 
                pass
        
        return status

    # Bind email buttons
    send_email_btn.click(
        send_to_managers,
        inputs=[role_state, entry_table],
        outputs=[email_status]
    )

    send_custom_btn.click(
        send_to_custom,
        inputs=[role_state, entry_table, email_recipients, email_note],
        outputs=[custom_email_status]
    )


# ======================
# LAUNCH APPLICATION
# ======================
if __name__ == "__main__":
    # Auto-detect LAN IP address
    local_ip = "127.0.0.1"
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(0.1)
        s.connect(("10.255.255.255", 1))
        local_ip = s.getsockname()[0]
        s.close()
    except Exception:
        try:
            local_ip = socket.gethostbyname(socket.gethostname())
            if local_ip.startswith("127.") or ":" in local_ip:
                local_ip = "YOUR_LOCAL_IP"
        except:
            local_ip = "YOUR_LOCAL_IP"
    
    demo.launch()