import gradio as gr
import sqlite3
import pandas as pd
import os
import datetime
import socket
import io
from pathlib import Path
import base64  # ADD THIS WITH OTHER IMPORTS
import tempfile  # ADD THIS WITH OTHER IMPORTS

# ======================
# EMAIL CONFIGURATION & HELPERS
# ======================
import os
import re
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import mimetypes


# GET IP ADDRESS TO DISPLAY IN EMAILS
def get_IP():
    # Auto-detect LAN IP address
    local_ip = "127.0.0.1"
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(0.1)
        s.connect(("10.255.255.255", 1))
        local_ip = s.getsockname()[0]
        s.close()
        return local_ip
    except Exception:
        try:
            local_ip = socket.gethostbyname(socket.gethostname())
            if local_ip.startswith("127.") or ":" in local_ip:
                local_ip = "YOUR_LOCAL_IP"
                return local_ip
        except:
            local_ip = "YOUR_LOCAL_IP"    
            return local_ip

MYLOCALIP = get_IP()

# SECURITY: Load credentials from environment variables ONLY (NEVER hardcode)
SENDER_EMAIL = "fabio.matricardi@gmail.com"
GMAIL_APP_PASSWORD = "vgrv oyhe tral kdaq"  # Must be set externally
MANAGER_EMAILS_FILE = "emails.txt"  # File with manager emails (one per line)

def read_manager_emails():
    """Read validated manager emails from file with error handling"""
    email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
    emails = []
    
    if not os.path.exists(MANAGER_EMAILS_FILE):
        return [], f"‚ùå Email file '{MANAGER_EMAILS_FILE}' not found. Create file with manager emails."
    
    try:
        with open(MANAGER_EMAILS_FILE, 'r', encoding='utf-8') as f:
            for line in f:
                email = line.strip()
                if email and not email.startswith('#') and email_pattern.match(email):
                    emails.append(email)
        
        if not emails:
            return [], f"‚ùå No valid emails found in '{MANAGER_EMAILS_FILE}'. Format: one email per line."
        return emails, None
    except Exception as e:
        return [], f"‚ùå Error reading email file: {str(e)}"

def send_email_with_exports(recipients, role, excel_path, pdf_path, custom_note=""):
    """Send email with export attachments - returns status message"""
    if not GMAIL_APP_PASSWORD:
        return "‚ùå EMAIL NOT CONFIGURED: Set FGS_GMAIL_APP_PASSWORD environment variable"
    
    if not recipients:
        return "‚ùå No valid recipients provided"
    
    # Generate timestamp for subject/body
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Build email content
    subject = f"FGS Override Register Export - {timestamp}"
    body = f"""FGS Override Register Export
Generated by: {role}
Timestamp: {timestamp}
{('Note: ' + custom_note) if custom_note else ''}

Attachments:
1. FULL_DATABASE_EXPORT.xlsx - Complete override register
2. CURRENT_VIEW_PRINTOUT.pdf - Filtered table as displayed

‚ö†Ô∏è CONFIDENTIAL: This document contains operational safety data.
Do not forward outside Congo FLNG personnel.

---
Automated message from CCR Master Override Register System
IP ADDRESS: {MYLOCALIP}
"""
    
    # Create message
    message = MIMEMultipart()
    message['Subject'] = subject
    message['From'] = SENDER_EMAIL
    message['To'] = ', '.join(recipients[:3]) + (f" + {len(recipients)-3} more" if len(recipients) > 3 else "")
    
    message.attach(MIMEText(body, 'plain'))
    
    # Attach files
    attachments = []
    for filepath, name in [(excel_path, "FULL_DATABASE_EXPORT.xlsx"), (pdf_path, "CURRENT_VIEW_PRINTOUT.pdf")]:
        if os.path.exists(filepath):
            try:
                ctype, _ = mimetypes.guess_type(filepath)
                maintype, subtype = (ctype or 'application/octet-stream').split('/', 1)
                
                with open(filepath, 'rb') as fp:
                    part = MIMEBase(maintype, subtype)
                    part.set_payload(fp.read())
                encoders.encode_base64(part)
                part.add_header('Content-Disposition', 'attachment', filename=name)
                message.attach(part)
                attachments.append(name)
            except Exception as e:
                print(f"‚ö†Ô∏è  Attachment error ({name}): {str(e)}")
    
    if len(attachments) < 2:
        return f"‚ùå Failed to attach required files. Attached: {', '.join(attachments)}"
    
    # Send email
    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465, timeout=30) as server:
            server.login(SENDER_EMAIL, GMAIL_APP_PASSWORD)
            server.send_message(message, to_addrs=recipients)
        return f"‚úÖ Email sent to {len(recipients)} recipient(s)! ({', '.join(attachments)})"
    except smtplib.SMTPAuthenticationError:
        return "‚ùå EMAIL AUTH FAILED: Invalid GMAIL_APP_PASSWORD. Contact administrator."
    except Exception as e:
        return f"‚ùå Email failed: {str(e)[:100]}"


# ======================
# SHUTDOWN LOG FUNCTIONS (Top-level for scheduler access)
# ======================
import json  # Ensure json is imported at top of file if not already

SHUTDOWN_FILE = "shutdown.json"
SHUTDOWN_COLUMNS = ['ID', 'timestamp', 'Event Description', 'First Cause', 'Issues and next steps', 'Action by', 'Reported by']

# Initialize shutdown.json if missing
if not os.path.exists(SHUTDOWN_FILE):
    with open(SHUTDOWN_FILE, 'w') as f:
        json.dump([], f)

def load_shutdown_events():
    """Load shutdown events from JSON"""
    try:
        with open(SHUTDOWN_FILE, 'r') as f:
            return json.load(f)
    except:
        return []

def get_filtered_shutdowns(filters):
    """Apply filters to shutdown events"""
    events = load_shutdown_events()
    if not events:
        return pd.DataFrame(columns=SHUTDOWN_COLUMNS)
    df = pd.DataFrame(events, columns=SHUTDOWN_COLUMNS)
    for col, val in filters.items():
        if val and val.strip():
            df = df[df[col].astype(str).str.contains(val, case=False, na=False)]
    return df.sort_values('ID', ascending=False).reset_index(drop=True)

def export_shutdown_excel_for_scheduler():
    """Export shutdown log to Excel (scheduler-compatible)"""
    df = get_filtered_shutdowns({})
    if df.empty:
        return None, "No shutdown events to export"
    
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"ShutdownLog_Export_{timestamp}.xlsx"
    temp_dir = tempfile.gettempdir()
    filepath = os.path.join(temp_dir, filename)
    
    try:
        with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
            pd.DataFrame([["PLANT SHUTDOWN EVENT LOG - OFFICIAL RECORD"]]).to_excel(
                writer, sheet_name='ShutdownLog', index=False, header=False
            )
            pd.DataFrame([[f"Exported on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"]]).to_excel(
                writer, sheet_name='ShutdownLog', startrow=1, index=False, header=False
            )
            df.to_excel(writer, sheet_name='ShutdownLog', startrow=3, index=False)
        return filepath, "Shutdown log Excel export successful"
    except Exception as e:
        return None, f"Shutdown Excel export failed: {str(e)}"

def export_shutdown_pdf_for_scheduler(table_df):
    """Export shutdown log to PDF (scheduler-compatible)"""
    try:
        from fpdf import FPDF, XPos, YPos
    except ImportError:
        return None, "PDF library not installed"
    
    try:
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        filename = f"ShutdownLog_A3_{timestamp}.pdf"
        temp_dir = tempfile.gettempdir()
        filepath = os.path.join(temp_dir, filename)
        
        pdf = FPDF(orientation='L', unit='mm', format='A3')
        pdf.add_page()
        pdf.set_font("Helvetica", "B", 16)
        pdf.cell(0, 12, text="PLANT SHUTDOWN EVENT LOG - OFFICIAL RECORD",
                new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.set_font("Helvetica", "", 11)
        gen_timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        pdf.cell(0, 9, text=f"Generated on: {gen_timestamp} | Format: A3 Landscape | CONFIDENTIAL",
                new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.ln(8)
        
        col_widths = [12, 35, 80, 80, 100, 30, 30]
        pdf.set_font("Helvetica", "B", 8)
        pdf.set_fill_color(220, 230, 240)
        for i, header in enumerate(SHUTDOWN_COLUMNS):
            pdf.cell(col_widths[i], 10, text=str(header), border=1, align='C', fill=True)
        pdf.ln()
        
        pdf.set_font("Helvetica", "", 7)
        rows = table_df.values.tolist() if not table_df.empty else []
        for row in rows:
            cell_heights = []
            for i, item in enumerate(row):
                txt = str(item).strip() if pd.notna(item) else ""
                lines = pdf.multi_cell(col_widths[i] - 2, 4.5, txt, split_only=True)
                height = len(lines) * 4.5 + 2
                cell_heights.append(height)
            row_height = max(max(cell_heights), 9)
            y_start = pdf.get_y()
            x_start = pdf.get_x()
            
            for i, width in enumerate(col_widths):
                x_pos = x_start + sum(col_widths[:i])
                pdf.rect(x_pos, y_start, width, row_height)
            
            for i, item in enumerate(row):
                txt = str(item).strip() if pd.notna(item) else ""
                x_pos = x_start + sum(col_widths[:i])
                lines = pdf.multi_cell(col_widths[i] - 2, 4.5, txt, split_only=True)
                text_height = len(lines) * 4.5
                y_offset = (row_height - text_height) / 2 if row_height > text_height else 1
                pdf.set_xy(x_pos + 1, y_start + y_offset)
                pdf.multi_cell(w=col_widths[i] - 2, h=4.5, txt=txt, border=0, 
                              new_x=XPos.RIGHT, new_y=YPos.TOP, max_line_height=4.5, align='L')
            pdf.set_xy(x_start, y_start + row_height)
        
        pdf.ln(12)
        pdf.set_font("Helvetica", "I", 10)
        pdf.cell(0, 9, text=f"Document ID: SHUTDOWN-LOG-{timestamp.replace('_', '')} | Total Events: {len(rows)} | CONFIDENTIAL",
                new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.set_font("Helvetica", "", 9)
        pdf.cell(0, 7, text="WARNING: Deletion of shutdown records is PROHIBITED per FLNG Safety Procedure SP-SHUT-001",
                new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.cell(0, 7, text="This document is valid only with printed timestamp. Electronic version available in CCR Shutdown Log application.",
                new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.cell(0, 7, text=f"System IP: {MYLOCALIP} | Generated by: CCR Master Override Register System",
                new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        
        pdf.output(filepath)
        if not os.path.exists(filepath) or os.path.getsize(filepath) == 0:
            if os.path.exists(filepath):
                os.remove(filepath)
            return None, "PDF file empty after generation"
        return filepath, "Shutdown log PDF export successful"
    except Exception as e:
        if 'filepath' in locals() and os.path.exists(filepath):
            try: os.remove(filepath)
            except: pass
        return None, f"PDF generation failed: {str(e)}"


# ======================
# DATABASE SETUP
# ======================
DB_PATH = "fgs_overrides.db"
EXCEL_PATH = "20260129_CCR_BPO_register_FGS_consolidated.xlsx"

manual_file = "manual.md"  # ‚úÖ Fixed typo
try:
    with open(manual_file, 'r', encoding='utf-8') as f:
        usermanual = f.read()
except FileNotFoundError:
    # ‚úÖ Fallback content if file missing (prevents startup crash)
    usermanual = """# üìò FGS Master Override Register - User Manual
‚ö†Ô∏è **manual.md not found**  
Place your user manual in Markdown format at `manual.md` in the application directory.
"""

def init_database():
    """Initialize SQLite database from Excel file if not exists"""
    if os.path.exists(DB_PATH):
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='overrides'")
        if cursor.fetchone():
            conn.close()
            return
        conn.close()
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS overrides (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            entry_no INTEGER UNIQUE NOT NULL,
            approved TEXT DEFAULT 'NO',
            closed TEXT DEFAULT 'NO',
            time_in TEXT,
            module_parameter TEXT,
            description TEXT,
            alarm TEXT,
            message TEXT,
            priority TEXT,
            status TEXT,
            date_on TEXT,
            requested_by TEXT,
            date_off TEXT,
            removal_requested_by TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')

    # ADD COLUMN MIGRATION AFTER TABLE CREATION (after line 60):
    # Check and add new columns if missing (for existing databases)
    cursor.execute("PRAGMA table_info(overrides)")
    existing_cols = [row[1] for row in cursor.fetchall()]
    if 'approved' not in existing_cols:
        cursor.execute("ALTER TABLE overrides ADD COLUMN approved TEXT DEFAULT 'NO'")
        cursor.execute("UPDATE overrides SET approved = 'NO' WHERE approved IS NULL")
    if 'closed' not in existing_cols:
        cursor.execute("ALTER TABLE overrides ADD COLUMN closed TEXT DEFAULT 'NO'")
        cursor.execute("UPDATE overrides SET closed = 'NO' WHERE closed IS NULL")

    
    try:
        if os.path.exists(EXCEL_PATH):
            df = pd.read_excel(EXCEL_PATH, skiprows=13, header=0)
            df.columns = df.columns.str.strip().str.replace(r'\s+', ' ', regex=True)
            
            column_mapping = {
                'no': 'entry_no', 'No': 'entry_no',
                'Time in': 'time_in', 'Time In': 'time_in',
                'Module Parameter': 'module_parameter',
                'Description': 'description',
                'Alarm': 'alarm',
                'Message': 'message',
                'Priority': 'priority',
                'Status': 'status',
                'Date on': 'date_on', 'Date On': 'date_on',
                'Requested by': 'requested_by', 'Requested By': 'requested_by',
                'Date off': 'date_off', 'Date Off': 'date_off',
                'Removal Requested by': 'removal_requested_by', 'Removal Requested By': 'removal_requested_by'
            }
            
            df = df.rename(columns=column_mapping)
            required_cols = ['entry_no', 'time_in', 'module_parameter', 'description', 
                           'alarm', 'message', 'priority', 'status', 'date_on', 
                           'requested_by', 'date_off', 'removal_requested_by']
            
            for col in required_cols:
                if col not in df.columns:
                    df[col] = ""
            
            df = df[required_cols].copy()
            df['entry_no'] = pd.to_numeric(df['entry_no'], errors='coerce').fillna(0).astype(int)
            df = df[df['entry_no'] > 0]
            
            if not df.empty:
                df.to_sql('overrides', conn, if_exists='append', index=False)
                print(f"Loaded {len(df)} entries from Excel")
            else:
                print("Excel file had no valid entries, using fallback data")
        else:
            print(f"Excel file not found at {EXCEL_PATH}, using fallback data")
    except Exception as e:
        print(f"Excel import failed ({e}), using fallback data")
    
    cursor.execute("SELECT COUNT(*) FROM overrides")
    if cursor.fetchone()[0] == 0:
        # UPDATE FALLBACK DATA (replace lines 108-115):
        fallback_data = [
            (1, "NO", "NO", "1/29/26 9:12", "77ATFZP01-301", "P01 flare vent header GAS detector bypass (forced in logic)", 
             "FGS bypass", "", "critical", "second event - risk assessment ongoing", "1/29/26", "OIM", "", ""),
            (2, "NO", "NO", "1/29/26 9:12", "77ATFZP01-302", "P01 flare vent header GAS detector bypass (forced in logic)", 
             "FGS bypass", "", "critical", "second event - risk assessment ongoing", "1/29/26", "OIM", "", "")
        ]
        # UPDATE INSERT STATEMENT (replace lines 117-122):
        cursor.executemany('''
            INSERT INTO overrides (
                entry_no, approved, closed, time_in, module_parameter, description, alarm, message, 
                priority, status, date_on, requested_by, date_off, removal_requested_by
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', fallback_data)
        print("Inserted fallback data")
    
    conn.commit()
    conn.close()
    print("Database initialized successfully")

# ======================
# AUTHENTICATION & POLICIES
# ======================
USERS = {
    "user": {"password": "user", "role": "viewer"},
    "manager": {"password": "manager", "role": "editor"},
    "admin": {"password": "admin", "role": "admin"}
}

def authenticate(username, password):
    """Validate credentials and return role"""
    user = USERS.get(username)
    if user and user["password"] == password:
        return True, user["role"], f"Welcome {username} ({user['role'].title()})!"
    return False, None, "Invalid credentials. Try: user/user, manager/manager, admin/admin"

def can_create(role): return role in ["viewer", "editor", "admin"]
def can_edit(role): return role in ["editor", "admin"]
def can_delete(role): return role in ["editor", "admin"]

# ======================
# DATABASE OPERATIONS
# ======================
# UPDATE COLUMN DEFINITIONS (REPLACE EXISTING DISPLAY_COLUMNS AND DB_COLUMN_MAPPING)
DISPLAY_COLUMNS = [
    'No', 'Approved', 'Closed', 'Time In', 'Module Parameter', 'Description', 
    'Alarm', 'Message', 'Priority', 'Status', 'Date On', 'Requested By', 
    'Date Off', 'Removal Requested By'
]

DB_COLUMN_MAPPING = {
    'No': 'entry_no',
    'Approved': 'approved',
    'Closed': 'closed',
    'Time In': 'time_in',
    'Module Parameter': 'module_parameter',
    'Description': 'description',
    'Alarm': 'alarm',
    'Message': 'message',
    'Priority': 'priority',
    'Status': 'status',
    'Date On': 'date_on',
    'Requested By': 'requested_by',
    'Date Off': 'date_off',
    'Removal Requested By': 'removal_requested_by'
}
reverse_mapping = {v: k for k, v in DB_COLUMN_MAPPING.items()}

def get_filtered_data(filters, sort_col="entry_no", sort_asc=True):
    """Fetch filtered data with SQL injection protection"""
    conn = sqlite3.connect(DB_PATH)
    
    where_clauses = []
    params = []
    for col, val in filters.items():
        if val and val.strip():
            db_col = DB_COLUMN_MAPPING.get(col, col.replace(" ", "_").lower())
            where_clauses.append(f"{db_col} LIKE ?")
            params.append(f"%{val}%")
    
    where_sql = "WHERE " + " AND ".join(where_clauses) if where_clauses else ""
    order_sql = f"ORDER BY {sort_col} {'ASC' if sort_asc else 'DESC'}"
    
    query = f"SELECT * FROM overrides {where_sql} {order_sql}"
    df = pd.read_sql_query(query, conn, params=params)
    conn.close()
    
    df = df.rename(columns=reverse_mapping)
    
    for col in DISPLAY_COLUMNS:
        if col not in df.columns:
            df[col] = ""
    
    return df[DISPLAY_COLUMNS] if not df.empty else pd.DataFrame(columns=DISPLAY_COLUMNS)

def get_entry_by_no(entry_no):
    """Fetch single entry details"""
    conn = sqlite3.connect(DB_PATH)
    df = pd.read_sql_query("SELECT * FROM overrides WHERE entry_no = ?", conn, params=(entry_no,))
    conn.close()
    if df.empty:
        return None
    
    record = df.iloc[0].to_dict()
    return {reverse_mapping.get(k, k): v for k, v in record.items()}

def save_entry(data, is_new, current_user):
    """Insert or update entry"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    fields = {}
    for ui_col, db_col in DB_COLUMN_MAPPING.items():
        fields[db_col] = data.get(ui_col, "")
    
    if is_new:
        cursor.execute("SELECT MAX(entry_no) FROM overrides")
        max_no = cursor.fetchone()[0] or 0
        entry_no = max_no + 1
        fields['entry_no'] = entry_no
    else:
        entry_no = int(data['No'])
    
    if not fields['requested_by'] and is_new:
        fields['requested_by'] = current_user
    
    if is_new:
        cols = ', '.join(fields.keys())
        placeholders = ', '.join(['?'] * len(fields))
        query = f"INSERT INTO overrides ({cols}) VALUES ({placeholders})"
        cursor.execute(query, list(fields.values()))
    else:
        set_clause = ', '.join([f"{k} = ?" for k in fields.keys() if k != 'entry_no'])
        query = f"UPDATE overrides SET {set_clause} WHERE entry_no = ?"
        cursor.execute(query, [fields[k] for k in fields.keys() if k != 'entry_no'] + [entry_no])
    
    conn.commit()
    conn.close()
    return entry_no

def delete_entry(entry_no):
    """Delete entry by number"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("DELETE FROM overrides WHERE entry_no = ?", (entry_no,))
    conn.commit()
    conn.close()

# ======================
# EXPORT & PRINT FUNCTIONS
# ======================
def export_entire_database(role):
    """Export ENTIRE database to Excel using temporary file (Gradio 4.x compatible)"""
    if not role:
        return None, "‚ùå Not authenticated. Please login first."
    
    try:
        conn = sqlite3.connect(DB_PATH)
        df = pd.read_sql_query("SELECT * FROM overrides", conn)
        conn.close()
        
        df = df.rename(columns=reverse_mapping)
        df = df[[col for col in DISPLAY_COLUMNS if col in df.columns]]
        
        # Create temporary file with proper cleanup
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"FGS_Export_{timestamp}.xlsx"
        temp_dir = tempfile.gettempdir()
        filepath = os.path.join(temp_dir, filename)
        
        # Write Excel file
        with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
            # Title row
            pd.DataFrame([["FGS MASTER OVERRIDE REGISTER - FULL DATABASE EXPORT"]]).to_excel(
                writer, sheet_name='Overrides', index=False, header=False
            )
            # Timestamp row
            pd.DataFrame([[f"Exported on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"]]).to_excel(
                writer, sheet_name='Overrides', startrow=1, index=False, header=False
            )
            # Data rows
            df.to_excel(writer, sheet_name='Overrides', startrow=3, index=False)
        
        return filepath, f"‚úÖ Exported {len(df)} entries to Excel"
    except Exception as e:
        return None, f"‚ùå Export failed: {str(e)}"

def print_current_table_to_pdf(table_df, role):
    """Generate PDF on A3 landscape with optimized layout (no truncation, full readability)"""
    if not role:
        return None, "‚ùå Not authenticated. Please login first."
    
    try:
        from fpdf import FPDF, XPos, YPos
    except ImportError:
        return None, "‚ùå PDF library not installed. Run: pip install fpdf2"
    
    try:
        # Create temp file path (Gradio 4.x compatible)
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        filename = f"FGS_Printout_A3_{timestamp}.pdf"
        temp_dir = tempfile.gettempdir()
        filepath = os.path.join(temp_dir, filename)
        
        # A3 LANDSCAPE: 420mm width √ó 297mm height (vs A4's 297√ó210)
        pdf = FPDF(orientation='L', unit='mm', format='A3')
        pdf.add_page()
        
        # Title section
        pdf.set_font("Helvetica", "B", 16)
        pdf.cell(0, 12, text="CCR MASTER OVERRIDE REGISTER - OFFICIAL PRINTOUT", 
                 new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.set_font("Helvetica", "", 11)
        gen_timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        pdf.cell(0, 9, text=f"Generated on: {gen_timestamp} | User: {role} | Format: A3 Landscape", 
                 new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.ln(8)
        
        # OPTIMIZED COLUMN WIDTHS FOR A3 (Total: 400mm = A3 width - 20mm margins)
        col_widths = [
            8,   # No (increased for better spacing)
            10,   # Approved (NEW)
            10,   # Closed (NEW)            
            28,   # Time In
            30,   # Module Parameter (critical field)
            85,   # Description (MAJOR increase - fits full text)
            22,   # Alarm
            22,   # Message
            17,   # Priority
            60,   # Status (MAJOR increase - fits risk assessments)
            28,   # Date On
            25,   # Requested By
            28,   # Date Off
            25    # Removal Requested By
        ]
        total_width = sum(col_widths)  # 400mm - perfect for A3
        
        # Header row with enhanced styling
        pdf.set_font("Helvetica", "B", 8)
        pdf.set_fill_color(230, 230, 250)  # Light purple header
        headers = DISPLAY_COLUMNS
        
        for i, header in enumerate(headers):
            pdf.cell(col_widths[i], 11, text=str(header), border=1, align='C', fill=True)
        pdf.ln()
        
        # Data rows with dynamic height calculation
        pdf.set_font("Helvetica", "", 7)
        rows = table_df.values.tolist() if not table_df.empty else []
        
        for row in rows:
            # Calculate required row height based on longest text in critical columns
            max_lines = 1
            for i, item in enumerate(row):
                txt = str(item).strip() if pd.notna(item) else ""
                col_width = col_widths[i]
                
                # Critical columns get multi-line support
                if i in [3, 7]:  # Description and Status
                    # Estimate lines needed (8pt font ‚âà 15 chars per 10mm width)
                    chars_per_line = max(1, int(col_width * 1.4))
                    lines = (len(txt) // chars_per_line) + 1
                    max_lines = max(max_lines, lines)
            
            row_height = max(9, max_lines * 4.5)  # Minimum 9mm height
            
            # Draw cells with calculated height
            for i, item in enumerate(row):
                txt = str(item).strip() if pd.notna(item) else ""
                align = 'L'
                
                # Special handling for numeric columns
                if i == 0:  # Entry No
                    align = 'C'
                    if txt.isdigit():
                        txt = str(int(float(txt))) if txt else ""
                
                pdf.cell(col_widths[i], row_height, text=txt, border=1, align=align)
            pdf.ln(row_height)
        
        # Professional footer
        pdf.ln(10)
        pdf.set_font("Helvetica", "I", 10)
        pdf.cell(0, 10, text=f"Document ID: FGS-PRINT-{timestamp.replace('_', '')} | Total Entries: {len(rows)} | CONFIDENTIAL", 
                 new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        pdf.set_font("Helvetica", "", 9)
        pdf.cell(0, 8, text="This document is valid only with printed timestamp. Electronic version available in CCR Master Override Register application.", 
                 new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        
        # Save to temp file (Gradio 4.x compatible)
        pdf.output(filepath)
        return filepath, f"‚úÖ A3 PDF generated ({len(rows)} entries) | {gen_timestamp}"
    except Exception as e:
        return None, f"‚ùå PDF generation failed: {str(e)}"


def import_excel_data(file_path, role):
    """Admin-only: Import Excel data appending to database (skip duplicates)"""
    if role != 'admin':
        return "‚ùå Access denied! Admin privileges required for imports."
    if not file_path:
        return "‚ùå No file uploaded. Please select an Excel file."
    
    try:
        if not Path(file_path).suffix.lower() in ['.xlsx', '.xls']:
            return "‚ùå Invalid file type. Please upload .xlsx or .xls files only."
        
        df = pd.read_excel(file_path, skiprows=13, header=0)
        df.columns = df.columns.str.strip().str.replace(r'\s+', ' ', regex=True)
        
        column_mapping = {
            'no': 'entry_no', 'No': 'entry_no',
            'Time in': 'time_in', 'Time In': 'time_in',
            'Module Parameter': 'module_parameter',
            'Description': 'description',
            'Alarm': 'alarm',
            'Message': 'message',
            'Priority': 'priority',
            'Status': 'status',
            'Date on': 'date_on', 'Date On': 'date_on',
            'Requested by': 'requested_by', 'Requested By': 'requested_by',
            'Date off': 'date_off', 'Date Off': 'date_off',
            'Removal Requested by': 'removal_requested_by', 'Removal Requested By': 'removal_requested_by'
        }
        
        # Ensure new columns exist with defaults
        for col in ['approved', 'closed']:
            if col not in df.columns:
                df[col] = "NO"  # Default for missing approval columns
            else:
                # Clean existing values to YES/NO standard
                df[col] = df[col].fillna("NO").apply(
                    lambda x: "YES" if str(x).strip().upper() in ["YES", "Y", "TRUE", "1"] else "NO"
                )        
        df = df.rename(columns=column_mapping)
        required_cols = list(DB_COLUMN_MAPPING.values())
        
        for col in required_cols:
            if col not in df.columns:
                df[col] = ""
        
        df = df[required_cols].copy()
        df['entry_no'] = pd.to_numeric(df['entry_no'], errors='coerce').fillna(0).astype(int)
        df = df[df['entry_no'] > 0].drop_duplicates(subset=['entry_no'])
        
        if df.empty:
            return "‚ùå No valid entries found in file. Check format matches original database."
        
        conn = sqlite3.connect(DB_PATH)
        existing_nos = pd.read_sql_query("SELECT entry_no FROM overrides", conn)['entry_no'].tolist()
        new_entries = df[~df['entry_no'].isin(existing_nos)]
        
        if new_entries.empty:
            conn.close()
            return "‚ÑπÔ∏è All entries already exist in database. No new entries added."
        
        new_entries.to_sql('overrides', conn, if_exists='append', index=False)
        conn.close()
        
        return f"‚úÖ Import successful! Added {len(new_entries)} new entries. ({len(df) - len(new_entries)} duplicates skipped.)"
    except Exception as e:
        return f"‚ùå Import failed: {str(e)}\nEnsure file matches original database format (skip 13 title rows)."

# COLOR STYLING FOR TABLE BASED ON RULES
def style_dataframe_for_display(df):
    """Apply row-wise background coloring based on Approved/Closed status"""
    if df.empty or 'Approved' not in df.columns or 'Closed' not in df.columns:
        return df
    
    def row_styler(row):
        approved = str(row['Approved']).strip().upper()
        closed = str(row['Closed']).strip().upper()
        
        # Apply styling rules
        if approved == 'NO':
            color = 'yellow'  # Pending approval
        elif approved == 'YES' and closed == 'NO':
            color = 'lightgreen'  # Approved but active
        elif approved == 'YES' and closed == 'YES':
            color = 'lightgray'  # Completed/closed
        else:
            return [''] * len(row)
        
        return [f'background-color: {color}; font-weight: bold' if i == 0 else f'background-color: {color}' 
                for i in range(len(row))]
    
    return df.style.apply(row_styler, axis=1)


def generate_email_exports(role, table_df):
    """
    Generate fresh Excel + PDF exports for email (without UI updates)
    Returns: (excel_path, pdf_path, error_message)
    """
    try:
        # Generate Excel export (FULL database)
        excel_path, _ = export_entire_database(role)
        if excel_path is None:
            return None, None, "‚ùå Excel export failed"
        
        # Generate PDF export (CURRENT filtered view)
        pdf_path, _ = print_current_table_to_pdf(table_df, role)
        if pdf_path is None:
            # Cleanup Excel if PDF fails
            try: os.remove(excel_path) 
            except: pass
            return None, None, "‚ùå PDF export failed"
        
        return excel_path, pdf_path, None
    except Exception as e:
        return None, None, f"‚ùå Export generation failed: {str(e)}"


# ======================
# SCHEDULER SECTION
# ======================
import schedule
import threading
import time
import pytz
from datetime import datetime as dt

# CONFIGURE TIMEZONE (CRITICAL FOR CONGO FLNG)
SCHEDULER_TIMEZONE = pytz.timezone('Africa/Brazzaville')  # Congo Republic timezone
LAST_SENT_TRACKER = {"05:00": None, "17:00": None}  # Prevent duplicate sends on restart

def send_scheduled_email():
    """Automated daily email to managers with FULL exports (Overrides + Shutdown Logs)"""
    try:
        now = dt.now(SCHEDULER_TIMEZONE)
        timestamp = now.strftime("%Y-%m-%d %H:%M:%S")
        schedule_time = "05:00" if now.hour < 12 else "17:00"
        
        today = now.date()
        if LAST_SENT_TRACKER[schedule_time] == today:
            print(f"[SCHEDULER] Skipped duplicate send for {schedule_time} on {today}")
            return
        LAST_SENT_TRACKER[schedule_time] = today
        
        print(f"\n{'='*60}")
        print(f"[SCHEDULER] üìß Sending INTEGRATED REPORT at {timestamp} ({schedule_time})")
        print(f"{'='*60}")
        
        managers, error = read_manager_emails()
        if error:
            print(f"[SCHEDULER] ‚ùå Email config error: {error}")
            return
        if not managers:
            print("[SCHEDULER] ‚ùå No valid manager emails found")
            return
        
        # ===== GENERATE OVERRIDE EXPORTS =====
        excel_path, _ = export_entire_database(role="system")
        if not excel_path:
            raise Exception("Override Excel export failed")
        
        full_df = get_filtered_data({})
        pdf_path, _ = print_current_table_to_pdf(full_df, role="system")
        if not pdf_path:
            os.remove(excel_path)
            raise Exception("Override PDF export failed")
        
        # ===== GENERATE SHUTDOWN LOG EXPORTS =====
        shutdown_excel_path, shutdown_excel_msg = export_shutdown_excel_for_scheduler()
        if not shutdown_excel_path:
            for p in [excel_path, pdf_path]:
                if p and os.path.exists(p): os.remove(p)
            raise Exception(f"Shutdown Excel export failed: {shutdown_excel_msg}")
        
        shutdown_df = get_filtered_shutdowns({})
        shutdown_pdf_path, shutdown_pdf_msg = export_shutdown_pdf_for_scheduler(shutdown_df)
        if not shutdown_pdf_path:
            for p in [excel_path, pdf_path, shutdown_excel_path]:
                if p and os.path.exists(p): os.remove(p)
            raise Exception(f"Shutdown PDF export failed: {shutdown_pdf_msg}")
        
        # ===== BUILD INTEGRATED EMAIL =====
        custom_note = (
            f"AUTOMATED SCHEDULED REPORT\n"
            f"Generated at: {timestamp} (Congo FLNG Time)\n"
            f"Schedule: Daily at 05:00 and 17:00\n"
            f"-----------------------------------\n"
            f"IP ADDRESS: {MYLOCALIP}\n"
            f"\nOVERRIDES SUMMARY:\n"
            f"  ‚Ä¢ Total Active: {len(full_df[full_df['Closed'] == 'NO'])}\n"
            f"  ‚Ä¢ Pending Approvals (Yellow): {len(full_df[full_df['Approved'] == 'NO'])}\n"
            f"\nSHUTDOWN LOG SUMMARY:\n"
            f"  ‚Ä¢ Total Events: {len(shutdown_df)}\n"
            f"  ‚Ä¢ Recent Event (ID #{shutdown_df['ID'].max() if not shutdown_df.empty else 'N/A'}): "
            f"{shutdown_df.iloc[-1]['Event Description'] if not shutdown_df.empty else 'N/A'}"
        )
        
        subject = f"CCR INTEGRATED REPORT - Overrides + Shutdown Log ({timestamp})"
        body = f"""CCR OPERATOR SYSTEM AUTOMATED REPORT
Generated by: System Scheduler
Timestamp: {timestamp} (Congo FLNG Time)
Schedule: Daily at 05:00 and 17:00 Congo Time

{custom_note}

üìé ATTACHMENTS (4 FILES):
1. OVERRIDES_FULL_DATABASE.xlsx - Complete override register
2. OVERRIDES_CURRENT_VIEW.pdf - Filtered table (A3 Landscape)
3. SHUTDOWN_LOG_FULL_EXPORT.xlsx - Complete shutdown event log
4. SHUTDOWN_LOG_CURRENT_VIEW.pdf - Shutdown events (A3 Landscape)

‚ö†Ô∏è CONFIDENTIAL: Contains operational safety data. Do not forward outside Congo FLNG personnel.
---
Automated message from CCR Master Override Register System
IP ADDRESS: {MYLOCALIP}
"""
        
        # Create message with all 4 attachments
        message = MIMEMultipart()
        message['Subject'] = subject
        message['From'] = SENDER_EMAIL
        message['To'] = ', '.join(managers[:3]) + (f" + {len(managers)-3} more" if len(managers) > 3 else "")
        message.attach(MIMEText(body, 'plain'))
        
        all_attachments = [
            (excel_path, "OVERRIDES_FULL_DATABASE.xlsx"),
            (pdf_path, "OVERRIDES_CURRENT_VIEW.pdf"),
            (shutdown_excel_path, "SHUTDOWN_LOG_FULL_EXPORT.xlsx"),
            (shutdown_pdf_path, "SHUTDOWN_LOG_CURRENT_VIEW.pdf")
        ]
        
        attached_names = []
        for filepath, name in all_attachments:
            if os.path.exists(filepath):
                try:
                    ctype, _ = mimetypes.guess_type(filepath)
                    maintype, subtype = (ctype or 'application/octet-stream').split('/', 1)
                    with open(filepath, 'rb') as fp:
                        part = MIMEBase(maintype, subtype)
                        part.set_payload(fp.read())
                    encoders.encode_base64(part)
                    part.add_header('Content-Disposition', 'attachment', filename=name)
                    message.attach(part)
                    attached_names.append(name)
                except Exception as e:
                    print(f"[SCHEDULER] Attachment error ({name}): {str(e)}")
        
        if len(attached_names) < 4:
            for filepath, _ in all_attachments:
                try:
                    if filepath and os.path.exists(filepath):
                        os.remove(filepath)
                except: pass
            raise Exception(f"Failed to attach required files. Attached: {', '.join(attached_names)}")
        
        # Send email
        try:
            with smtplib.SMTP_SSL('smtp.gmail.com', 465, timeout=30) as server:
                server.login(SENDER_EMAIL, GMAIL_APP_PASSWORD)
                server.send_message(message, to_addrs=managers)
        except smtplib.SMTPAuthenticationError:
            for filepath, _ in all_attachments:
                try:
                    if filepath and os.path.exists(filepath):
                        os.remove(filepath)
                except: pass
            raise Exception("EMAIL AUTH FAILED: Invalid GMAIL_APP_PASSWORD")
        
        # Cleanup ALL temp files
        for filepath, _ in all_attachments:
            try:
                if filepath and os.path.exists(filepath):
                    os.remove(filepath)
            except Exception as e:
                print(f"[SCHEDULER] Cleanup warning: {str(e)}")
        
        # Log success
        recipient_count = len(managers)
        print(f"[SCHEDULER] ‚úÖ SUCCESS: Integrated report sent to {recipient_count} manager(s)")
        print(f"              Overrides: OVERRIDES_FULL_DATABASE.xlsx + OVERRIDES_CURRENT_VIEW.pdf")
        print(f"              Shutdown Log: SHUTDOWN_LOG_FULL_EXPORT.xlsx + SHUTDOWN_LOG_CURRENT_VIEW.pdf")
        print(f"              Next scheduled send: {'17:00' if schedule_time == '05:00' else '05:00 (next day)'}")
        print("="*60 + "\n")
        
    except Exception as e:
        print(f"[SCHEDULER] ‚ùå FAILED: {str(e)}")
        import traceback
        traceback.print_exc()

def start_email_scheduler():
    """Initialize background scheduler with Congo timezone awareness"""
    def run_scheduler():
        print("\n" + "="*70)
        print("üìß SCHEDULED EMAIL SYSTEM INITIALIZED")
        print("="*70)
        print(f"üìç Timezone: {SCHEDULER_TIMEZONE}")
        print(f"‚è∞ Schedule: Daily at 05:00 and 17:00 Congo Time")
        print(f"üì¨ Recipients: Managers from '{MANAGER_EMAILS_FILE}'")
        print(f"üìé Attachments: FULL_DATABASE_EXPORT.xlsx + CURRENT_VIEW_PRINTOUT.pdf")
        print(f"üåê ORIGIN IP ADDRESS:  {MYLOCALIP}")
        print("-"*70)
        
        # Schedule jobs using Congo time
        schedule.every().day.at("05:00", SCHEDULER_TIMEZONE).do(send_scheduled_email)
        schedule.every().day.at("17:00", SCHEDULER_TIMEZONE).do(send_scheduled_email)
        
        #######################################################
        #######################################################
        # IMMEDIATE TEST ON STARTUP (COMMENT OUT IN PRODUCTION)
        print("‚ö†Ô∏è  TEST MODE: Sending immediate test email...")
        send_scheduled_email()
        #######################################################
        
        print("‚úÖ Scheduler active - monitoring for scheduled sends")
        print("="*70 + "\n")
        
        while True:
            schedule.run_pending()
            time.sleep(30)  # Check every 30 seconds
    
    # Start daemon thread (exits when main app exits)
    scheduler_thread = threading.Thread(target=run_scheduler, daemon=True, name="EmailScheduler")
    scheduler_thread.start()
    return scheduler_thread




# ======================
# GRADIO INTERFACE
# ======================
def create_app():
    init_database()
    
    with gr.Blocks(title="CCR Override Register") as app:
        role_state = gr.State(None)
        current_entry_state = gr.State(None)
        form_mode_state = gr.State("view")
        
        # LOGIN PAGE
        with gr.Column(visible=True) as login_page:
            with gr.Row():  #equal_height=True
                with gr.Column(scale=1):
                    gr.Markdown()
                with gr.Column(scale=1):
                    gr.Markdown("# \n# üîí CCR Master Override Register")
                    gr.Markdown(f"\n #### Network IP: {MYLOCALIP}")
                with gr.Column(scale=1):
                    gr.Markdown()

            gr.Markdown("*(Login with your credentials...)*")
            gr.Markdown("---")
            with gr.Row():
                with gr.Column(scale=1):             
                    gr.Image("wisonLOGO.png", width=150, container=False, buttons=[])
                    #gr.Image("congoFLNG.png", width=150, container=False, buttons=[])  
                with gr.Column(scale=2):
                    username = gr.Textbox(label="Username", placeholder="Enter username")
                    password = gr.Textbox(label="Password", type="password", placeholder="Enter password")
                    login_btn = gr.Button("Login", variant="primary")
                    gr.Markdown("---")
                    login_msg = gr.Textbox(label="Status", interactive=False)
                with gr.Column(scale=1):
                    gr.Markdown()
                    gr.Image("ENIcongo.jpg", width=150, container=False, buttons=[])
                    #gr.Image("logo.png", width=150, container=False, buttons=[])
            with gr.Row():
                gr.Markdown("---")
            with gr.Row():    
                with gr.Column(scale=1):
                    gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
                with gr.Column(scale=2):
                    gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                    gr.Markdown(f"#### Network IP: {MYLOCALIP}")

        # MAIN APPLICATION
        with gr.Column(visible=False) as main_app:
            with gr.Row():
                with gr.Column(scale=1, variant='compact'):
                    with gr.Row():
                        gr.Image("wisonLOGO.png", height=30, container=False, buttons=[], scale=1)
                        gr.Image("congoFLNG.png", height=30, container=False, buttons=[], scale=1)                       
                with gr.Column(scale=3):
                    gr.Markdown()
                    gr.Markdown("# üîí CCR Master Override Register")
                with gr.Column(scale=1, variant='compact'):
                    gr.Image("ENIcongo.jpg", height=30, container=False, buttons=[], scale=1)
                    gr.Image("logo.png", height=30, container=False, buttons=[], scale=1)
            gr.Markdown("---")
            
            with gr.Tabs() as tabs:
                # MAIN REGISTER TAB
                with gr.Tab("üìã Main Register"):
                    with gr.Row():
                        user_display = gr.Textbox(label="Logged in as", interactive=False)
                        logout_btn = gr.Button("üö™ Logout", scale=0)
                    
                    gr.Markdown("## üîç Override Register Entries")
                    with gr.Row():
                        # Add this BELOW entry_table in UI definition (around line 340):
                        gr.Markdown("""
                        <div style="display: flex; gap: 20px; margin: 10px 0; padding: 8px; background: #f8f9fa; border-radius: 5px;">
                          <span style="background: yellow; padding: 2px 8px; border-radius: 3px">üü° Pending Approval</span>
                          <span style="background: lightgreen; padding: 2px 8px; border-radius: 3px">üü¢ Active Override</span>
                          <span style="background: lightgray; padding: 2px 8px; border-radius: 3px">‚ö™ Closed</span>
                        </div>
                        """)                    
                    filter_inputs = {}
                    with gr.Row():
                        for col in DISPLAY_COLUMNS[:4]:
                            filter_inputs[col] = gr.Textbox(label=col, placeholder=f"Filter {col}...", container=False)
                    with gr.Row():
                        for col in DISPLAY_COLUMNS[4:8]:
                            filter_inputs[col] = gr.Textbox(label=col, placeholder=f"Filter {col}...", container=False)
                    with gr.Row():
                        for col in DISPLAY_COLUMNS[8:]:
                            filter_inputs[col] = gr.Textbox(label=col, placeholder=f"Filter {col}...", container=False)
                    
                    filter_btn = gr.Button("Apply Filters", variant="secondary")
                    

                    entry_table = gr.Dataframe(
                        headers=DISPLAY_COLUMNS,
                        datatype=["str"] * len(DISPLAY_COLUMNS),
                        interactive=False,
                        wrap=True,
                        label="Override Entries"
                    )
                    
                    with gr.Row():
                        entry_selector = gr.Dropdown(
                            label="Select Entry No to View/Edit", 
                            choices=[],
                            interactive=True
                        )
                        load_btn = gr.Button("Load Selected Entry", variant="primary")
                        create_btn = gr.Button("‚ûï Create New Entry", variant="secondary")


                    
                    # Detail form
                    gr.Markdown("## üìù Entry Details")
                    with gr.Column():
                        form_fields = {}
                        # Row 1: Entry No + New Approval Fields
                        with gr.Row():
                            form_fields['No'] = gr.Number(label="Entry No", interactive=False)
                            form_fields['Approved'] = gr.Dropdown(
                                label="Approved", 
                                choices=["YES", "NO"], 
                                value="NO",
                                interactive=False  # Will be enabled for manager/admin only
                            )
                            form_fields['Closed'] = gr.Dropdown(
                                label="Closed", 
                                choices=["YES", "NO"], 
                                value="NO",
                                interactive=False  # Will be enabled for manager/admin only
                            )
                        
                        # Row 2: Time fields
                        with gr.Row():
                            form_fields['Time In'] = gr.Textbox(label="Time In")
                            form_fields['Date On'] = gr.Textbox(label="Date On")
                            form_fields['Date Off'] = gr.Textbox(label="Date Off")
                        
                        # Row 3: Critical parameters
                        with gr.Row():
                            form_fields['Module Parameter'] = gr.Textbox(label="Module Parameter", scale=2)
                            form_fields['Alarm'] = gr.Textbox(label="Alarm Type")
                            form_fields['Priority'] = gr.Dropdown(
                                label="Priority", 
                                choices=["critical", "high", "medium", "low"],
                                value="critical"
                            )
                        
                        # Remaining fields (unchanged)
                        form_fields['Description'] = gr.Textbox(label="Description", lines=2)
                        form_fields['Message'] = gr.Textbox(label="Message")
                        form_fields['Status'] = gr.Textbox(label="Status", lines=2)
                        form_fields['Requested By'] = gr.Textbox(label="Requested By")
                        form_fields['Removal Requested By'] = gr.Textbox(label="Removal Requested By")
                        
                        # Action buttons (unchanged)
                        with gr.Row():
                            save_btn = gr.Button("üíæ Save Changes", variant="primary", visible=True)
                            delete_btn = gr.Button("üóëÔ∏è Delete Entry", variant="stop", visible=False)
                            cancel_btn = gr.Button("‚Ü∫ Cancel", variant="secondary")
                    
                    status_msg = gr.Textbox(label="Operation Status", interactive=False)


                    # Export/Print Section
                    gr.Markdown("## üì§ Export, Print & Email")
                    with gr.Row():
                        export_excel_btn = gr.Button("üì§ Export FULL Database to Excel", variant="secondary")
                        print_pdf_btn = gr.Button("üñ®Ô∏è Print CURRENT Table to PDF", variant="secondary")
                        send_email_btn = gr.Button("‚úâÔ∏è Send by Email (Managers)", variant="primary")  # NEW BUTTON
                    with gr.Row():
                        export_file = gr.File(label="üì• Download Excel Export", type="filepath", visible=True)
                        print_file = gr.File(label="üñ®Ô∏è Download PDF Printout", type="filepath", visible=True)
                        email_status = gr.Textbox(label="üìß Email Status", interactive=False, visible=True)  # NEW STATUS
                    with gr.Row():
                        gr.Markdown("---")
                    with gr.Row():    
                        with gr.Column(scale=1):
                            gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
                        with gr.Column(scale=2):
                            gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                            gr.Markdown(f"#### Network IP: {MYLOCALIP}")

                # ADMIN PANEL TAB (only visible to admin)
                with gr.Tab("‚öôÔ∏è Admin Panel", id="admin_tab", visible=False) as admin_tab:
                    gr.Markdown("## üîê Admin Operations")
                    gr.Markdown("### üì• Import Excel Data")
                    gr.Markdown("Upload Excel files matching the original database format. **Existing entries (by Entry No) will be skipped.**")
                    with gr.Row():
                        excel_upload = gr.File(
                            label="Upload Excel File (.xlsx/.xls)", 
                            type="filepath", 
                            file_types=[".xlsx", ".xls"]
                        )
                        import_btn = gr.Button("‚úÖ Import Data", variant="primary", size="lg")
                    import_status = gr.Textbox(label="Import Status", interactive=False, max_lines=3)
                    gr.Markdown("---")
                    gr.Markdown("‚ÑπÔ∏è **Import Notes:**\n"
                              "- File must have same structure as original database (skip 13 title rows)\n"
                              "- Only NEW entries (by Entry No) will be added\n"
                              "- Duplicates are automatically skipped\n"
                              "- Admin access required")
                    with gr.Row():
                        gr.Markdown("---")
                    with gr.Row():    
                        with gr.Column(scale=1):
                            gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
                        with gr.Column(scale=2):
                            gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                            gr.Markdown(f"#### Network IP: {MYLOCALIP}")


                # ===== CUSTOM EMAIL TAB (VISIBLE TO ALL USERS) =====
                with gr.Tab("üìß Custom Email"):
                    gr.Markdown("## üìß Send Current Exports to Custom Recipients")
                    gr.Markdown("Enter email addresses below (one per line). Attachments will include:")
                    gr.Markdown("- **FULL_DATABASE_EXPORT.xlsx**: Complete override register\n- **CURRENT_VIEW_PRINTOUT.pdf**: Filtered table as displayed")
                    
                    with gr.Row():
                        email_recipients = gr.Textbox(
                            label="Recipient Emails (one per line)",
                            placeholder="manager1@congoflng.com\nsupervisor2@wison.com\nhse@congoflng.com",
                            lines=5,
                            max_lines=20
                        )
                    with gr.Row():
                        email_note = gr.Textbox(label="Optional Note (appears in email body)", placeholder="Shift handover report - 06:00")
                        send_custom_btn = gr.Button("üì§ Send Custom Email", variant="primary", size="lg")
                    custom_email_status = gr.Textbox(label="Status", interactive=False, max_lines=3)
                    
                    gr.Markdown("---")
                    gr.Markdown("‚ÑπÔ∏è **Security Notes**:\n- Emails sent via secure Gmail API\n- Attachments contain CONFIDENTIAL operational data\n- Only send to authorized Congo FLNG personnel\n- System logs all email requests")
                    with gr.Row():
                        gr.Markdown("---")
                    with gr.Row():    
                        with gr.Column(scale=1):
                            gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
                        with gr.Column(scale=2):
                            gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                            gr.Markdown(f"#### Network IP: {MYLOCALIP}")

                # ===== SHUTDOWN LOG TAB (VISIBLE TO ALL USERS) =====
                with gr.Tab("üìù SHUTDOWN LOG"):
                    gr.Markdown("## üö® Plant Shutdown Event Log")
                    gr.Markdown("Log all unplanned/planned shutdown events. *All entries are permanent audit records.*")
                    
                    # Export & Email buttons at top
                    with gr.Row():
                        shutdown_export_excel_btn = gr.Button("üì§ Export to Excel", variant="secondary")
                        shutdown_export_pdf_btn = gr.Button("üñ®Ô∏è Export to PDF (A3)", variant="secondary")
                        shutdown_send_email_btn = gr.Button("‚úâÔ∏è Send by Email (Managers)", variant="primary")  # NEW BUTTON
                    with gr.Row():
                        shutdown_export_file = gr.File(label="üì• Download Export", type="filepath", visible=True)
                        shutdown_email_status = gr.Textbox(label="üìß Email Status", interactive=False, visible=True)  # UPDATED
                    
                    # Filter section
                    gr.Markdown("## üîç Filter Shutdown Events")
                    SHUTDOWN_COLUMNS = ['ID', 'timestamp', 'Event Description', 'First Cause', 'Issues and next steps', 'Action by', 'Reported by']
                    shutdown_filter_inputs = {}
                    with gr.Row():
                        for col in SHUTDOWN_COLUMNS[:4]:
                            shutdown_filter_inputs[col] = gr.Textbox(label=col, placeholder=f"Filter {col}...", container=False)
                    with gr.Row():
                        for col in SHUTDOWN_COLUMNS[4:]:
                            shutdown_filter_inputs[col] = gr.Textbox(label=col, placeholder=f"Filter {col}...", container=False)
                    shutdown_filter_btn = gr.Button("Apply Filters", variant="secondary")
                    
                    # Events table
                    shutdown_table = gr.Dataframe(
                        headers=SHUTDOWN_COLUMNS,
                        datatype=["str"] * len(SHUTDOWN_COLUMNS),
                        interactive=False,
                        wrap=True,
                        label="Shutdown Events History"
                    )
                    
                    # Event selection for editing
                    with gr.Row():
                        shutdown_id_selector = gr.Dropdown(
                            label="Select Event ID to Edit", 
                            choices=[],
                            interactive=True,
                            scale=3
                        )
                        shutdown_load_event_btn = gr.Button("‚úèÔ∏è Load Selected Event", variant="primary", scale=1)
                    
                    # Event form
                    gr.Markdown("## ‚ûï Add New Event / ‚úèÔ∏è Edit Existing Event")
                    with gr.Row():
                        shutdown_id = gr.Number(label="ID (Auto-generated for new events)", interactive=False, scale=1)
                        shutdown_timestamp = gr.Textbox(
                            label="Timestamp (YYYY-MM-DD HH:MM:SS)", 
                            value=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            scale=2
                        )
                    with gr.Row():
                        shutdown_event_desc = gr.Textbox(label="Event Description", lines=2, max_lines=5, scale=2)
                        shutdown_first_cause = gr.Textbox(label="First Cause", lines=2, max_lines=5, scale=1)
                    with gr.Row():
                        shutdown_issues_next_steps = gr.Textbox(label="Issues and next steps", lines=3, max_lines=10, scale=2)
                        with gr.Column(scale=1):
                            shutdown_action_by = gr.Textbox(label="Action by")
                            shutdown_reported_by = gr.Textbox(label="Reported by")
                    
                    # Action buttons
                    with gr.Row():
                        shutdown_add_new_btn = gr.Button("‚ûï Add New Event", variant="primary")
                        shutdown_save_btn = gr.Button("üíæ Save Event", variant="primary", visible=False)
                        shutdown_cancel_btn = gr.Button("‚Ü∫ Cancel", variant="secondary")
                    
                    shutdown_status_msg = gr.Textbox(label="Operation Status", interactive=False)

                    with gr.Row():
                        gr.Markdown("---")
                    with gr.Row():    
                        with gr.Column(scale=1):
                            gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
                        with gr.Column(scale=2):
                            gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                            gr.Markdown(f"#### Network IP: {MYLOCALIP}")
                    
                    # ===== SHUTDOWN LOG INTERNAL LOGIC (Self-contained in tab) =====
                    import json
                    
                    SHUTDOWN_FILE = "shutdown.json"
                    
                    # Initialize JSON file if missing
                    if not os.path.exists(SHUTDOWN_FILE):
                        with open(SHUTDOWN_FILE, 'w') as f:
                            json.dump([], f)
                    
                    def load_shutdown_events():
                        """Load events from JSON with error handling"""
                        try:
                            with open(SHUTDOWN_FILE, 'r') as f:
                                return json.load(f)
                        except:
                            return []
                    
                    def save_shutdown_events(events):
                        """Save events to JSON with backup"""
                        try:
                            # Create backup before writing
                            if os.path.exists(SHUTDOWN_FILE):
                                backup_path = SHUTDOWN_FILE.replace('.json', f'_backup_{datetime.datetime.now().strftime("%Y%m%d_%H%M%S")}.json')
                                import shutil
                                shutil.copy2(SHUTDOWN_FILE, backup_path)
                            with open(SHUTDOWN_FILE, 'w') as f:
                                json.dump(events, f, indent=2)
                            return True
                        except Exception as e:
                            print(f"Shutdown save error: {str(e)}")
                            return False
                    
                    def get_filtered_shutdowns(filters):
                        """Apply filters to shutdown events"""
                        events = load_shutdown_events()
                        if not events:
                            return pd.DataFrame(columns=SHUTDOWN_COLUMNS)
                        
                        df = pd.DataFrame(events, columns=SHUTDOWN_COLUMNS)
                        
                        # Apply filters
                        for col, val in filters.items():
                            if val and val.strip():
                                df = df[df[col].astype(str).str.contains(val, case=False, na=False)]
                        
                        return df.sort_values('ID', ascending=False).reset_index(drop=True)
                    
                    def export_shutdown_excel():
                        """Export shutdown log to Excel"""
                        df = get_filtered_shutdowns({})
                        if df.empty:
                            return None, "‚ùå No shutdown events to export"
                        
                        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
                        filename = f"ShutdownLog_Export_{timestamp}.xlsx"
                        temp_dir = tempfile.gettempdir()
                        filepath = os.path.join(temp_dir, filename)
                        
                        try:
                            with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
                                # Title rows
                                pd.DataFrame([["PLANT SHUTDOWN EVENT LOG - OFFICIAL RECORD"]]).to_excel(
                                    writer, sheet_name='ShutdownLog', index=False, header=False
                                )
                                pd.DataFrame([[f"Exported on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"]]).to_excel(
                                    writer, sheet_name='ShutdownLog', startrow=1, index=False, header=False
                                )
                                # Data
                                df.to_excel(writer, sheet_name='ShutdownLog', startrow=3, index=False)
                            return filepath, f"‚úÖ Exported {len(df)} shutdown events to Excel"
                        except Exception as e:
                            return None, f"‚ùå Export failed: {str(e)}"
                    

                    def export_shutdown_pdf(table_df):
                        """Export shutdown log to PDF (A3 Landscape) with true multi-line text wrapping"""
                        try:
                            from fpdf import FPDF, XPos, YPos
                        except ImportError:
                            return None, "‚ùå PDF library not installed. Run: pip install fpdf2"
                        
                        try:
                            timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                            filename = f"ShutdownLog_A3_{timestamp}.pdf"
                            temp_dir = tempfile.gettempdir()
                            filepath = os.path.join(temp_dir, filename)
                            
                            # A3 LANDSCAPE: 420mm width √ó 297mm height
                            pdf = FPDF(orientation='L', unit='mm', format='A3')
                            pdf.add_page()
                            
                            # Header section
                            pdf.set_font("Helvetica", "B", 16)
                            pdf.cell(0, 12, text="PLANT SHUTDOWN EVENT LOG - OFFICIAL RECORD", 
                                    new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
                            pdf.set_font("Helvetica", "", 11)
                            gen_timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                            pdf.cell(0, 9, text=f"Generated on: {gen_timestamp} | Format: A3 Landscape | CONFIDENTIAL", 
                                    new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
                            pdf.ln(8)
                            
                            # OPTIMIZED COLUMN WIDTHS FOR A3 LANDSCAPE (Total: 395mm)
                            col_widths = [
                                12,   # ID
                                35,   # timestamp
                                80,   # Event Description (critical field)
                                80,   # First Cause
                                100,  # Issues and next steps (MAJOR increase for multi-line)
                                30,   # Action by
                                30    # Reported by
                            ]
                            
                            # Header row with styling
                            pdf.set_font("Helvetica", "B", 8)
                            pdf.set_fill_color(220, 230, 240)  # Light blue header
                            for i, header in enumerate(SHUTDOWN_COLUMNS):
                                pdf.cell(col_widths[i], 10, text=str(header), border=1, align='C', fill=True)
                            pdf.ln()
                            
                            # Data rows with TRUE multi-line support using multi_cell
                            pdf.set_font("Helvetica", "", 7)
                            rows = table_df.values.tolist() if not table_df.empty else []
                            
                            for row in rows:
                                # FIRST PASS: Calculate required height for each cell using split_only
                                cell_heights = []
                                for i, item in enumerate(row):
                                    txt = str(item).strip() if pd.notna(item) else ""
                                    # Get line count without drawing (requires fpdf2 >= 2.7.0)
                                    lines = pdf.multi_cell(col_widths[i] - 2, 4.5, txt, split_only=True)
                                    height = len(lines) * 4.5 + 2  # 2mm vertical padding
                                    cell_heights.append(height)
                                
                                # Determine row height (max of all cells, min 9mm)
                                row_height = max(max(cell_heights), 9)
                                y_start = pdf.get_y()
                                x_start = pdf.get_x()
                                
                                # SECOND PASS: Draw cell borders
                                for i, width in enumerate(col_widths):
                                    x_pos = x_start + sum(col_widths[:i])
                                    pdf.rect(x_pos, y_start, width, row_height)
                                
                                # THIRD PASS: Draw text with proper vertical centering
                                for i, item in enumerate(row):
                                    txt = str(item).strip() if pd.notna(item) else ""
                                    x_pos = x_start + sum(col_widths[:i])
                                    
                                    # Calculate vertical centering offset
                                    lines = pdf.multi_cell(col_widths[i] - 2, 4.5, txt, split_only=True)
                                    text_height = len(lines) * 4.5
                                    y_offset = (row_height - text_height) / 2 if row_height > text_height else 1
                                    
                                    # Draw multi-line text
                                    pdf.set_xy(x_pos + 1, y_start + y_offset)  # 1mm left padding
                                    pdf.multi_cell(
                                        w=col_widths[i] - 2,
                                        h=4.5,
                                        txt=txt,
                                        border=0,
                                        new_x=XPos.RIGHT,
                                        new_y=YPos.TOP,
                                        max_line_height=4.5,
                                        align='L'
                                    )
                                
                                # Move to next row position
                                pdf.set_xy(x_start, y_start + row_height)
                            
                            # COMPLIANCE FOOTER (ASCII-safe - NO EMOJIS)
                            pdf.ln(12)
                            pdf.set_font("Helvetica", "I", 10)
                            pdf.cell(0, 9, text=f"Document ID: SHUTDOWN-LOG-{timestamp.replace('_', '')} | Total Events: {len(rows)} | CONFIDENTIAL", 
                                    new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
                            pdf.set_font("Helvetica", "", 9)
                            pdf.cell(0, 7, text="WARNING: Deletion of shutdown records is PROHIBITED per FLNG Safety Procedure SP-SHUT-001", 
                                    new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
                            pdf.cell(0, 7, text="This document is valid only with printed timestamp. Electronic version available in CCR Shutdown Log application.", 
                                    new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
                            pdf.cell(0, 7, text=f"System IP: {MYLOCALIP} | Generated by: CCR Master Override Register System", 
                                    new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
                            
                            # Save PDF with validation
                            pdf.output(filepath)
                            
                            # Verify file integrity
                            if not os.path.exists(filepath) or os.path.getsize(filepath) == 0:
                                if os.path.exists(filepath):
                                    os.remove(filepath)
                                return None, "‚ùå PDF generation failed: File empty after output"
                            
                            return filepath, f"‚úÖ A3 PDF generated ({len(rows)} events) | {gen_timestamp}"
                            
                        except Exception as e:
                            # Cleanup failed file
                            if 'filepath' in locals() and os.path.exists(filepath):
                                try: 
                                    os.remove(filepath)
                                except: 
                                    pass
                            return None, f"‚ùå PDF generation failed: {str(e)}"

                    
                    # ===== SHUTDOWN TAB EVENT HANDLERS =====
                    def refresh_shutdown_view(filters_dict=None):
                        """Refresh table and ID selector"""
                        if filters_dict is None:
                            filters_dict = {col: "" for col in SHUTDOWN_COLUMNS}
                        df = get_filtered_shutdowns(filters_dict)
                        events = load_shutdown_events()
                        id_choices = [str(e['ID']) for e in events] if events else []
                        return (
                            df,
                            gr.update(choices=id_choices, value=None),
                            gr.update(value="", interactive=False),  # ID field
                            gr.update(value=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")),  # Timestamp
                            gr.update(value=""),  # Event Desc
                            gr.update(value=""),  # First Cause
                            gr.update(value=""),  # Issues
                            gr.update(value=""),  # Action by
                            gr.update(value=""),  # Reported by
                            gr.update(visible=False),  # Save btn
                            gr.update(value="")  # Status
                        )
                    
                    def load_selected_event(event_id_str):
                        """Load event into form for editing"""
                        if not event_id_str:
                            return {shutdown_status_msg: "‚ùå Please select an Event ID"}
                        
                        try:
                            event_id = int(event_id_str)
                        except:
                            return {shutdown_status_msg: "‚ùå Invalid Event ID"}
                        
                        events = load_shutdown_events()
                        event = next((e for e in events if e['ID'] == event_id), None)
                        
                        if not event:
                            return {shutdown_status_msg: f"‚ùå Event ID {event_id} not found"}
                        
                        return {
                            shutdown_id: gr.update(value=event['ID'], interactive=False),
                            shutdown_timestamp: gr.update(value=event.get('timestamp', '')),
                            shutdown_event_desc: gr.update(value=event.get('Event Description', '')),
                            shutdown_first_cause: gr.update(value=event.get('First Cause', '')),
                            shutdown_issues_next_steps: gr.update(value=event.get('Issues and next steps', '')),
                            shutdown_action_by: gr.update(value=event.get('Action by', '')),
                            shutdown_reported_by: gr.update(value=event.get('Reported by', '')),
                            shutdown_save_btn: gr.update(visible=True, value="üíæ Update Event"),
                            shutdown_status_msg: f"‚úèÔ∏è Editing Event ID #{event_id}. Make changes and click 'Save Event'"
                        }
                    
                    def prepare_new_event():
                        """Reset form for new event"""
                        return {
                            shutdown_id: gr.update(value=None, interactive=False),
                            shutdown_timestamp: gr.update(value=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")),
                            shutdown_event_desc: gr.update(value=""),
                            shutdown_first_cause: gr.update(value=""),
                            shutdown_issues_next_steps: gr.update(value=""),
                            shutdown_action_by: gr.update(value=""),
                            shutdown_reported_by: gr.update(value=""),
                            shutdown_save_btn: gr.update(visible=True, value="‚úÖ Add New Event"),
                            shutdown_status_msg: "‚ûï Creating new shutdown event. Fill required fields and click 'Add New Event'"
                        }
                    
                    def save_shutdown_event(id_val, timestamp, desc, cause, issues, action_by, reported_by):
                        """Save new or updated event"""
                        # Validation
                        if not desc.strip():
                            return {shutdown_status_msg: "‚ùå Event Description is required"}
                        if not cause.strip():
                            return {shutdown_status_msg: "‚ùå First Cause is required"}
                        if not reported_by.strip():
                            return {shutdown_status_msg: "‚ùå Reported by is required"}
                        
                        events = load_shutdown_events()
                        
                        # Prepare event data
                        event_data = {
                            'ID': id_val,
                            'timestamp': timestamp.strip() or datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            'Event Description': desc.strip(),
                            'First Cause': cause.strip(),
                            'Issues and next steps': issues.strip(),
                            'Action by': action_by.strip(),
                            'Reported by': reported_by.strip()
                        }
                        
                        if id_val:  # Update existing
                            for i, e in enumerate(events):
                                if e['ID'] == id_val:
                                    events[i] = event_data
                                    break
                            action = "updated"
                        else:  # Create new
                            new_id = max((e['ID'] for e in events), default=0) + 1
                            event_data['ID'] = new_id
                            events.append(event_data)
                            action = "created"
                        
                        # Save with backup
                        if save_shutdown_events(events):
                            # Refresh view
                            df = get_filtered_shutdowns({})
                            id_choices = [str(e['ID']) for e in events]
                            return {
                                shutdown_table: df,
                                shutdown_id_selector: gr.update(choices=id_choices),
                                shutdown_id: gr.update(value=None, interactive=False),
                                shutdown_timestamp: gr.update(value=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")),
                                shutdown_event_desc: gr.update(value=""),
                                shutdown_first_cause: gr.update(value=""),
                                shutdown_issues_next_steps: gr.update(value=""),
                                shutdown_action_by: gr.update(value=""),
                                shutdown_reported_by: gr.update(value=""),
                                shutdown_save_btn: gr.update(visible=False),
                                shutdown_status_msg: f"‚úÖ Event ID #{event_data['ID']} successfully {action}! (Permanent audit record)"
                            }
                        else:
                            return {shutdown_status_msg: "‚ùå Save failed. Check file permissions."}
                    
                    def apply_shutdown_filters(*filter_vals):
                        """Apply filters to shutdown table"""
                        filters = dict(zip(SHUTDOWN_COLUMNS, filter_vals))
                        df = get_filtered_shutdowns(filters)
                        events = load_shutdown_events()
                        id_choices = [str(e['ID']) for e in events] if events else []
                        return {
                            shutdown_table: df,
                            shutdown_id_selector: gr.update(choices=id_choices)
                        }
                    
                    def export_shutdown_excel_handler():
                        filepath, msg = export_shutdown_excel()
                        if filepath and os.path.exists(filepath) and os.path.getsize(filepath) > 0:
                            return filepath, msg, gr.update(visible=True)
                        return None, msg, gr.update(visible=False)
                    
                    def export_shutdown_pdf_handler():
                        df = get_filtered_shutdowns({})  # Export ALL events (unfiltered)
                        filepath, msg = export_shutdown_pdf(df)
                        if filepath and os.path.exists(filepath) and os.path.getsize(filepath) > 0:
                            return filepath, msg, gr.update(visible=True)
                        return None, msg, gr.update(visible=False)
                    

                    def send_shutdown_to_managers(role):
                        """Send shutdown log exports to managers from emails.txt"""
                        if not role:
                            return "‚ùå Not authenticated. Please login first."
                        
                        managers, error = read_manager_emails()
                        if error:
                            return error
                        
                        # Generate Excel export
                        excel_path, excel_msg = export_shutdown_excel()
                        if excel_path is None:
                            return excel_msg
                        
                        # Generate PDF export (ALL events)
                        df = get_filtered_shutdowns({})
                        pdf_path, pdf_msg = export_shutdown_pdf(df)
                        if pdf_path is None:
                            try: os.remove(excel_path)
                            except: pass
                            return pdf_msg
                        
                        # Send with shutdown-specific note
                        custom_note = (
                            "SHUTDOWN LOG EXPORT\n"
                            f"Generated at: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} (Congo FLNG Time)\n"
                            f"Total Events: {len(df)}\n"
                            f"IP ADDRESS: {MYLOCALIP}"
                        )
                        
                        status = send_email_with_exports(
                            recipients=managers,
                            role=role,
                            excel_path=excel_path,
                            pdf_path=pdf_path,
                            custom_note=custom_note
                        )
                        
                        # Cleanup temp files
                        for path in [excel_path, pdf_path]:
                            try:
                                if path and os.path.exists(path):
                                    os.remove(path)
                            except:
                                pass
                        
                        return status

                    # ===== SHUTDOWN TAB EVENT BINDINGS =====
                    shutdown_filter_btn.click(
                        apply_shutdown_filters,
                        inputs=[*[shutdown_filter_inputs[col] for col in SHUTDOWN_COLUMNS]],
                        outputs=[shutdown_table, shutdown_id_selector]
                    )
                    
                    shutdown_load_event_btn.click(
                        load_selected_event,
                        inputs=[shutdown_id_selector],
                        outputs=[
                            shutdown_id, shutdown_timestamp, shutdown_event_desc, shutdown_first_cause,
                            shutdown_issues_next_steps, shutdown_action_by, shutdown_reported_by,
                            shutdown_save_btn, shutdown_status_msg
                        ]
                    )
                    
                    shutdown_add_new_btn.click(
                        prepare_new_event,
                        outputs=[
                            shutdown_id, shutdown_timestamp, shutdown_event_desc, shutdown_first_cause,
                            shutdown_issues_next_steps, shutdown_action_by, shutdown_reported_by,
                            shutdown_save_btn, shutdown_status_msg
                        ]
                    )
                    
                    shutdown_save_btn.click(
                        save_shutdown_event,
                        inputs=[
                            shutdown_id, shutdown_timestamp, shutdown_event_desc, shutdown_first_cause,
                            shutdown_issues_next_steps, shutdown_action_by, shutdown_reported_by
                        ],
                        outputs=[
                            shutdown_table, shutdown_id_selector,
                            shutdown_id, shutdown_timestamp, shutdown_event_desc, shutdown_first_cause,
                            shutdown_issues_next_steps, shutdown_action_by, shutdown_reported_by,
                            shutdown_save_btn, shutdown_status_msg
                        ]
                    )
                    
                    shutdown_cancel_btn.click(
                        refresh_shutdown_view,
                        outputs=[
                            shutdown_table, shutdown_id_selector,
                            shutdown_id, shutdown_timestamp, shutdown_event_desc, shutdown_first_cause,
                            shutdown_issues_next_steps, shutdown_action_by, shutdown_reported_by,
                            shutdown_save_btn, shutdown_status_msg
                        ]
                    )
                    
                    shutdown_export_excel_btn.click(
                        export_shutdown_excel_handler,
                        outputs=[shutdown_export_file, shutdown_email_status, shutdown_export_file]  # ‚úÖ CORRECT
                    )

                    shutdown_export_pdf_btn.click(
                        export_shutdown_pdf_handler,
                        outputs=[shutdown_export_file, shutdown_email_status, shutdown_export_file]  # ‚úÖ CORRECT
                    )

                    shutdown_send_email_btn.click(
                        send_shutdown_to_managers,
                        inputs=[role_state],
                        outputs=[shutdown_email_status]
                    )                    


                    # Auto-refresh on tab load
                    app.load(
                        refresh_shutdown_view,
                        outputs=[
                            shutdown_table, shutdown_id_selector,
                            shutdown_id, shutdown_timestamp, shutdown_event_desc, shutdown_first_cause,
                            shutdown_issues_next_steps, shutdown_action_by, shutdown_reported_by,
                            shutdown_save_btn, shutdown_status_msg
                        ]
                    )


                # ========== MANUAL PANEL TAB (only visible to ALL) ==========
                with gr.Tab("üìö User Manual"):
                    with gr.Row():
                        gr.Markdown(usermanual)
                    with gr.Row():
                        gr.Markdown("---")
                    with gr.Row():    
                        with gr.Column(scale=1):
                            gr.Image("logo.png", height=50, container=False, buttons=[], scale=1)
                        with gr.Column(scale=2):
                            gr.Markdown("All rights reserved (C)\ncreated by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\nvisit [Key Solution SRL](key-solution.eu)")
                            gr.Markdown(f"#### Network IP: {MYLOCALIP}")

        
        # ===== EVENT HANDLERS =====
        def login_action(uname, pwd):
            if not uname or not uname.strip():
                return _create_login_response(
                    login_msg_text="‚ö†Ô∏è Username cannot be empty",
                    keep_username=""
                )
            
            if not pwd or not pwd.strip():
                return _create_login_response(
                    login_msg_text="‚ö†Ô∏è Password cannot be empty",
                    keep_username=uname.strip()
                )
            
            success, role, auth_msg = authenticate(uname.strip(), pwd.strip())
            if not success:
                return _create_login_response(
                    login_msg_text="‚ùå Invalid credentials! Try: user/user, manager/manager, or admin/admin",
                    keep_username=uname.strip()
                )
            
            df = get_filtered_data({})
            raw_df = get_filtered_data({})
            styled_df = style_dataframe_for_display(raw_df)
            entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
            form_vals = {k: "" for k in DISPLAY_COLUMNS}
            form_vals['Priority'] = "critical"
            
            outputs = {
                login_page: gr.update(visible=False),
                main_app: gr.update(visible=True),
                login_msg: gr.update(value=""),
                user_display: gr.update(value=f"{uname} ({role.title()})"),
                role_state: role,
                entry_table: styled_df,  # Replace df with styled_df
                entry_selector: gr.update(choices=entry_nums),
                status_msg: auth_msg,
                admin_tab: gr.update(visible=(role == "admin")),
            }
            for col in DISPLAY_COLUMNS:
                if col == 'Priority':
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
                else:
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
            outputs[save_btn] = gr.update(visible=False)
            outputs[delete_btn] = gr.update(visible=False)
            outputs[form_mode_state] = "view"
            outputs[username] = gr.update(value="")
            outputs[password] = gr.update(value="")
            outputs[export_file] = None  # Clears file download link
            outputs[print_file] = None   # Clears file download link
            return outputs

        def _create_login_response(login_msg_text, keep_username):
            form_vals = {k: "" for k in DISPLAY_COLUMNS}
            form_vals['Priority'] = "critical"
            
            outputs = {
                login_page: gr.update(visible=True),
                main_app: gr.update(visible=False),
                login_msg: gr.update(value=login_msg_text),
                user_display: gr.update(value=""),
                role_state: None,
                entry_table: pd.DataFrame(columns=DISPLAY_COLUMNS),
                entry_selector: gr.update(choices=[], value=None),
                status_msg: gr.update(value=""),
                admin_tab: gr.update(visible=False),
            }
            for col in DISPLAY_COLUMNS:
                if col == 'Priority':
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
                else:
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
            outputs[save_btn] = gr.update(visible=False)
            outputs[delete_btn] = gr.update(visible=False)
            outputs[form_mode_state] = "view"
            outputs[username] = gr.update(value=keep_username)
            outputs[password] = gr.update(value="")
            outputs[export_file] = None  # Clears file download link
            outputs[print_file] = None   # Clears file download link
            return outputs
        
        def logout_action():
            form_vals = {k: "" for k in DISPLAY_COLUMNS}
            form_vals['Priority'] = "critical"
            
            outputs = {
                login_page: gr.update(visible=True),
                main_app: gr.update(visible=False),
                username: gr.update(value=""),
                password: gr.update(value=""),
                login_msg: "Logged out successfully",
                role_state: None,
                admin_tab: gr.update(visible=False),
                export_file: gr.update(visible=False),
                print_file: gr.update(visible=False),
            }
            for col in DISPLAY_COLUMNS:
                if col == 'Priority':
                    outputs[form_fields[col]] = gr.update(value=form_vals[col])
                else:
                    outputs[form_fields[col]] = gr.update(value=form_vals[col])
            return outputs
        
        def apply_filters(*args):
            if len(args) < 15:  # 14 filters + role
                return {status_msg: "Filter error: insufficient inputs"}
            
            filter_vals = args[:14]
            role = args[14]
            
            filters = dict(zip(DISPLAY_COLUMNS, filter_vals))
            raw_df = get_filtered_data(filters)  # Keep raw for selector
            styled_df = style_dataframe_for_display(raw_df)  # Style for display
            
            entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
            
            return {
                entry_table: styled_df,  # CRITICAL: Use styled version
                entry_selector: gr.update(choices=entry_nums),
                status_msg: f"Showing {len(raw_df)} entries"
            }
        
        def load_entry(entry_no_str, role):
            if not entry_no_str or not entry_no_str.strip():
                return {status_msg: "Please select an entry number"}
            
            try:
                entry_no = int(float(entry_no_str))
            except (ValueError, TypeError):
                return {status_msg: "Invalid entry number"}
            
            entry = get_entry_by_no(entry_no)
            if not entry:
                return {status_msg: f"Entry #{entry_no} not found"}
            
            form_vals = {}
            for col in DISPLAY_COLUMNS:
                val = entry.get(col, "")
                if col == 'No':
                    try:
                        form_vals[col] = int(float(val)) if val else entry_no
                    except:
                        form_vals[col] = entry_no
                else:
                    form_vals[col] = str(val) if pd.notna(val) else ""
            
            interactive = can_edit(role)
            
            outputs = {
                current_entry_state: entry_no,
                form_mode_state: "edit",
                status_msg: f"Loaded entry #{entry_no} | Role: {role}",
            }

            # CRITICAL: Set interactivity for new fields
            approved_interactive = can_edit(role)
            closed_interactive = can_edit(role)            
            for col in DISPLAY_COLUMNS:
                if col == 'No':
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
                elif col == 'Approved':
                    outputs[form_fields[col]] = gr.update(
                        value=form_vals[col] if form_vals[col] in ["YES", "NO"] else "NO",
                        interactive=approved_interactive
                    )
                elif col == 'Closed':
                    outputs[form_fields[col]] = gr.update(
                        value=form_vals[col] if form_vals[col] in ["YES", "NO"] else "NO",
                        interactive=closed_interactive
                    )
                elif col == 'Priority':
                    outputs[form_fields[col]] = gr.update(
                        value=form_vals[col] if form_vals[col] in ["critical", "high", "medium", "low"] else "critical",
                        interactive=can_edit(role)
                    )
                else:
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=can_edit(role))
            
            outputs[save_btn] = gr.update(visible=can_edit(role))
            outputs[delete_btn] = gr.update(visible=can_delete(role))
            return outputs
        
        def create_new(role):
            conn = sqlite3.connect(DB_PATH)
            cursor = conn.cursor()
            cursor.execute("SELECT MAX(entry_no) FROM overrides")
            next_no = (cursor.fetchone()[0] or 0) + 1
            conn.close()
            
            now = datetime.datetime.now().strftime("%m/%d/%y %H:%M")
            today = datetime.datetime.now().strftime("%m/%d/%y")
            
            form_vals = {
                'No': next_no,
                'Approved': 'NO',  # Default values
                'Closed': 'NO',
                'Time In': now,
                'Module Parameter': "",
                'Description': "",
                'Alarm': "FGS bypass",
                'Message': "MOS active",
                'Priority': "critical",
                'Status': "",
                'Date On': today,
                'Requested By': role.capitalize(),
                'Date Off': "",
                'Removal Requested By': ""
            }
            
            outputs = {
                current_entry_state: None,
                form_mode_state: "create",
                status_msg: f"Creating new entry (No. {next_no}) | Role: {role}",
            }
            # CRITICAL: Set interactivity for new fields based on role
            approved_interactive = can_edit(role)  # Only manager/admin
            closed_interactive = can_edit(role)    # Only manager/admin
            
            for col in DISPLAY_COLUMNS:
                if col == 'No':
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
                elif col in ['Approved', 'Closed']:
                    outputs[form_fields[col]] = gr.update(
                        value=form_vals[col], 
                        interactive=approved_interactive if col=='Approved' else closed_interactive
                    )
                elif col == 'Priority':
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=True)
                else:
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=True)
            
            outputs[save_btn] = gr.update(visible=can_create(role), value="‚úÖ Create New Entry")
            outputs[delete_btn] = gr.update(visible=False)
            return outputs
        
        def save_action(*args):
            if len(args) < 17:  
                return {status_msg: f"Save error: insufficient inputs (expected 17, got {len(args)})"}
            
            # WAS: args[:12] ‚Üí NOW: args[:14] for all form fields
            field_vals = args[:14]  
            role = args[14]      # WAS args[12]
            mode = args[15]      # WAS args[13]
            current_no = args[16]  # WAS args[14]
            
            data = dict(zip(DISPLAY_COLUMNS, field_vals))  # Now includes Approved/Closed
            
            # Validation (unchanged)
            if not data['Module Parameter'].strip():
                return {status_msg: "Error: Module Parameter is required"}
            if not data['Description'].strip():
                return {status_msg: "Error: Description is required"}
            
            try:
                saved_no = save_entry(data, mode == "create", role)
                action = "created" if mode == "create" else "updated"
                
                df = get_filtered_data({})
                raw_df = get_filtered_data({})
                styled_df = style_dataframe_for_display(raw_df)
                entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
                
                outputs = {
                    status_msg: f"Entry #{saved_no} successfully {action}!",
                    entry_table: styled_df,  # Replace df with styled_df
                    entry_selector: gr.update(choices=entry_nums),
                    export_file: None,  # Clear previous exports
                    print_file: None,   # Clear previous prints
                }
                
                if mode == "create":
                    # Reset to NEW blank form (not load saved entry)
                    outputs.update(create_new(role))  
                else:
                    # Only reload for EDIT mode
                    outputs.update(load_entry(str(saved_no), role))  
                
                return outputs
                
            except Exception as e:
                return {status_msg: f"Save failed: {str(e)}"}
        
        def delete_action(entry_no, role):
            if not can_delete(role):
                return {status_msg: "Insufficient permissions to delete entries"}
            if not entry_no:
                return {status_msg: "No entry selected for deletion"}
            
            try:
                delete_entry(entry_no)
                df = get_filtered_data({})
                aw_df = get_filtered_data({})
                styled_df = style_dataframe_for_display(raw_df)
                entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
                
                form_vals = {k: "" for k in DISPLAY_COLUMNS}
                form_vals['Priority'] = "critical"
                
                outputs = {
                    status_msg: f"Entry #{entry_no} deleted successfully",
                    entry_table: styled_df,  # Replace df with styled_df
                    entry_selector: gr.update(choices=entry_nums),
                    export_file: gr.update(visible=True),
                    print_file: gr.update(visible=True),
                }
                for col in DISPLAY_COLUMNS:
                    if col == 'Priority':
                        outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
                    else:
                        outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
                
                outputs[save_btn] = gr.update(visible=False)
                outputs[delete_btn] = gr.update(visible=False)
                outputs[form_mode_state] = "view"
                return outputs
                
            except Exception as e:
                return {status_msg: f"Delete failed: {str(e)}"}
        
        def cancel_action(role):
            form_vals = {k: "" for k in DISPLAY_COLUMNS}
            form_vals['Priority'] = "critical"
            
            outputs = {
                status_msg: "Changes cancelled",
                form_mode_state: "view",
                current_entry_state: None,
                export_file: gr.update(visible=True),
                print_file: gr.update(visible=True),
            }
            for col in DISPLAY_COLUMNS:
                if col == 'Priority':
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
                else:
                    outputs[form_fields[col]] = gr.update(value=form_vals[col], interactive=False)
            
            outputs[save_btn] = gr.update(visible=False)
            outputs[delete_btn] = gr.update(visible=False)
            return outputs
        
        # ===== EVENT BINDINGS =====
        login_btn.click(
            login_action,
            inputs=[username, password],
            outputs=[
                login_page, main_app, login_msg, user_display, role_state, 
                entry_table, entry_selector, status_msg, admin_tab,
                *[form_fields[col] for col in DISPLAY_COLUMNS],
                save_btn, delete_btn, form_mode_state,
                username, password, export_file, print_file
            ]
        )
        
        logout_btn.click(
            logout_action,
            outputs=[
                login_page, main_app, username, password, login_msg, role_state, admin_tab,
                *[form_fields[col] for col in DISPLAY_COLUMNS],
                export_file, print_file
            ]
        )
        
        filter_btn.click(
            apply_filters,
            inputs=[*[filter_inputs[col] for col in DISPLAY_COLUMNS], role_state],
            outputs=[entry_table, entry_selector, status_msg]
        )
        
        load_btn.click(
            load_entry,
            inputs=[entry_selector, role_state],
            outputs=[
                current_entry_state, form_mode_state, status_msg,
                *[form_fields[col] for col in DISPLAY_COLUMNS],
                save_btn, delete_btn
            ]
        )
        
        create_btn.click(
            create_new,
            inputs=[role_state],
            outputs=[
                current_entry_state, form_mode_state, status_msg,
                *[form_fields[col] for col in DISPLAY_COLUMNS],
                save_btn, delete_btn
            ]
        )
        
        save_btn.click(
            save_action,
            inputs=[
                *[form_fields[col] for col in DISPLAY_COLUMNS],
                role_state, form_mode_state, current_entry_state
            ],
            outputs=[
                status_msg, entry_table, entry_selector,
                current_entry_state, form_mode_state,
                *[form_fields[col] for col in DISPLAY_COLUMNS],
                save_btn, delete_btn, export_file, print_file
            ]
        )
        
        delete_btn.click(
            delete_action,
            inputs=[current_entry_state, role_state],
            outputs=[
                status_msg, entry_table, entry_selector,
                *[form_fields[col] for col in DISPLAY_COLUMNS],
                save_btn, delete_btn, form_mode_state, export_file, print_file
            ]
        )
        
        cancel_btn.click(
            cancel_action,
            inputs=[role_state],
            outputs=[
                status_msg, form_mode_state, current_entry_state,
                *[form_fields[col] for col in DISPLAY_COLUMNS],
                save_btn, delete_btn, export_file, print_file
            ]
        )
        
        # Export/Print bindings
        export_excel_btn.click(
            export_entire_database,
            inputs=[role_state],
            outputs=[export_file, status_msg]
        )

        print_pdf_btn.click(
            print_current_table_to_pdf,
            inputs=[entry_table, role_state],
            outputs=[print_file, status_msg]
        )
        # Admin import binding
        # REMOVE existing import_btn.click chain and REPLACE with:
        def refresh_table_after_import(role):
            """Helper: Refresh table with styling + update selector"""
            raw_df = get_filtered_data({})
            styled_df = style_dataframe_for_display(raw_df)
            entry_nums = [str(int(x)) for x in raw_df['No'].tolist() if pd.notna(x) and x != ""] if not raw_df.empty else []
            return styled_df, gr.update(choices=entry_nums)

        import_btn.click(
            import_excel_data,
            inputs=[excel_upload, role_state],
            outputs=[import_status]
        ).then(
            refresh_table_after_import,
            inputs=[role_state],
            outputs=[entry_table, entry_selector]  # Single call updates both
        )


        # ===== EMAIL FUNCTIONALITY =====
        def send_to_managers(role, table_df):
            """Send exports to managers from emails.txt"""
            if not role:
                return "‚ùå Not authenticated. Please login first."
            
            managers, error = read_manager_emails()
            if error:
                return error
            
            excel_path, pdf_path, gen_error = generate_email_exports(role, table_df)
            if gen_error:
                return gen_error
            
            status = send_email_with_exports(managers, role, excel_path, pdf_path)
            
            # Cleanup temp files
            for path in [excel_path, pdf_path]:
                try: 
                    if path and os.path.exists(path): 
                        os.remove(path)
                except: 
                    pass
            
            return status

        def send_to_custom(role, table_df, recipients_text, note):
            """Send exports to custom email list"""
            if not role:
                return "‚ùå Not authenticated. Please login first."
            
            # Parse and validate emails
            email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
            recipients = []
            invalid = []
            
            for line in recipients_text.strip().split('\n'):
                email = line.strip()
                if email and not email.startswith('#'):
                    if email_pattern.match(email):
                        recipients.append(email)
                    else:
                        invalid.append(email)
            
            if invalid:
                return f"‚ùå Invalid emails skipped: {', '.join(invalid[:3])}{'...' if len(invalid)>3 else ''}"
            if not recipients:
                return "‚ùå No valid email addresses provided. Enter one per line."
            
            excel_path, pdf_path, gen_error = generate_email_exports(role, table_df)
            if gen_error:
                return gen_error
            
            status = send_email_with_exports(recipients, role, excel_path, pdf_path, note)
            
            # Cleanup
            for path in [excel_path, pdf_path]:
                try: 
                    if path and os.path.exists(path): 
                        os.remove(path)
                except: 
                    pass
            
            return status

        # Bind email buttons
        send_email_btn.click(
            send_to_managers,
            inputs=[role_state, entry_table],
            outputs=[email_status]
        )

        send_custom_btn.click(
            send_to_custom,
            inputs=[role_state, entry_table, email_recipients, email_note],
            outputs=[custom_email_status]
        )
    
    return app

# ======================
# LAUNCH APPLICATION
# ======================
if __name__ == "__main__":
    # Auto-detect LAN IP address
    local_ip = "127.0.0.1"
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(0.1)
        s.connect(("10.255.255.255", 1))
        local_ip = s.getsockname()[0]
        s.close()
    except Exception:
        try:
            local_ip = socket.gethostbyname(socket.gethostname())
            if local_ip.startswith("127.") or ":" in local_ip:
                local_ip = "YOUR_LOCAL_IP"
        except:
            local_ip = "YOUR_LOCAL_IP"
    
    app = create_app()

    # ======================
    # ACTIVATE EMAIL SCHEDULER (ADD THIS SECTION)
    # ======================
    try:
        # Verify email configuration before starting scheduler
        if not GMAIL_APP_PASSWORD:
            print("\n" + "‚ö†Ô∏è  " + "="*68)
            print("‚ö†Ô∏è  EMAIL SCHEDULER DISABLED: Set GMAIL_APP_PASSWORD environment variable")
            print("‚ö†Ô∏è  To enable automated reports:")
            print("‚ö†Ô∏è    GMAIL_APP_PASSWORD='your_16_digit_code'")
            print("‚ö†Ô∏è  " + "="*68 + "\n")
        elif not os.path.exists(MANAGER_EMAILS_FILE):
            print(f"\n‚ö†Ô∏è  EMAIL SCHEDULER DISABLED: Create '{MANAGER_EMAILS_FILE}' with manager emails\n")
        else:
            # START SCHEDULER (runs in background thread)
            scheduler_thread = start_email_scheduler()
            print(f"‚úÖ Email scheduler thread started: {scheduler_thread.name}")
    except Exception as e:
        print(f"\n‚ùå Scheduler initialization failed: {str(e)}\n")

    # PRINT MESSAGES FOR THE SERVER INITIALIZATION    
    border = "=" * 70
    print(f"\n{border}")
    print("üöÄ CCR MASTER OVERRIDE REGISTER - NETWORK ACCESS INFO")
    print(border)
    print(f"üìç LOCAL ACCESS (this machine):  http://127.0.0.1:7860")
    if local_ip != "YOUR_LOCAL_IP":
        print(f"üåê LAN ACCESS (other devices):   http://{local_ip}:7860")
        print(f"üåê LAN ACCESS (other devices):   http://inst.local:7860")
    else:
        print(f"üåê LAN ACCESS: Find your IP address:")
        print(f"   ‚Ä¢ Windows: Open CMD ‚Üí type 'ipconfig' ‚Üí look for 'IPv4 Address'")
        print(f"   ‚Ä¢ Then use: http://<YOUR_IP>:7860 from other devices")
    print("-" * 70)
    print("‚ö†Ô∏è  SECURITY NOTICE")
    print("   ‚Ä¢ Connection uses UNENCRYPTED HTTP - ONLY use on TRUSTED networks")
    print("   ‚Ä¢ Authentication required for all operations")
    print("üîí FIREWALL SETUP (CRITICAL FOR WINDOWS):")
    print("   1. Open 'Windows Security' ‚Üí Firewall & network protection")
    print("   2. Click 'Advanced settings' (left panel)")
    print("   3. Inbound Rules ‚Üí New Rule ‚Üí Port ‚Üí TCP 7860 ‚Üí Allow connection")
    print("   4. Name: 'FGS Override App' ‚Üí Finish")
    print(border + "\n")
    
    # Install PDF dependency if needed (one-time setup)
    try:
        from fpdf import FPDF
        print("‚úÖ PDF generation available (fpdf2 installed)")
    except ImportError:
        print("‚ÑπÔ∏è  PDF generation NOT available. To enable:")
        print("    pip install fpdf2")
    
    app.launch(
        server_name="0.0.0.0",
        server_port=7860,
        theme=gr.themes.Glass(),
        inbrowser=True
    )